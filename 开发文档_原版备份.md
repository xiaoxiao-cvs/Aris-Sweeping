# Minecraft 1.20.1 Forge Mod å¼€å‘æ–‡æ¡£
## å®ä½“æ¸…ç†ä¸å¯è§†åŒ–é…ç½®ç³»ç»Ÿ

### ç‰ˆæœ¬ä¿¡æ¯
- **Minecraftç‰ˆæœ¬**: 1.20.1
- **Forgeç‰ˆæœ¬**: 47.2.x
- **Javaç‰ˆæœ¬**: 17+
- **é¡¹ç›®åç§°**: ArisSweeping (å®ä½“æ¸…ç†æ¨¡ç»„)

### ğŸ“ˆ å½“å‰å¼€å‘è¿›åº¦ (æ›´æ–°æ—¶é—´: 2025å¹´9æœˆ19æ—¥)

#### âœ… é¡¹ç›®æ€»ä½“çŠ¶æ€
- **æ€»ä½“è¿›åº¦**: **90%** ğŸ‰ (é¡¹ç›®å·²æ¥è¿‘å®Œæˆï¼)
- **æ ¸å¿ƒç³»ç»Ÿ**: **95%** (æ‰€æœ‰ä¸»è¦åŠŸèƒ½å·²å®ç°)
- **ç”¨æˆ·ç•Œé¢**: **85%** (MiniHUDé£æ ¼ç•Œé¢åŸºæœ¬å®Œæˆ)
- **ç½‘ç»œé€šä¿¡**: **80%** (åŸºç¡€æ¶æ„å®Œæˆ)
- **æ•°æ®æŒä¹…åŒ–**: **95%** (å®Œæ•´å®ç°)

#### ğŸ¯ **é¡¹ç›®å·²è¾¾åˆ° Beta ç‰ˆæœ¬å°±ç»ªçŠ¶æ€**

---

## ğŸ“ æºä»£ç å®ç°çŠ¶æ€

### âœ… å·²å®Œæˆæ–‡ä»¶åˆ—è¡¨ (90%+ å®Œæˆåº¦)

| æ–‡ä»¶è·¯å¾„ | çŠ¶æ€ | å®Œæˆåº¦ | è¯´æ˜ |
|---------|------|--------|------|
| `ArisSweepingMod.java` | âœ… å®Œæˆ | 95% | æ¨¡ç»„ä¸»ç±»ï¼Œäº‹ä»¶å¤„ç†å’Œç®¡ç†å™¨é›†æˆ |
| `Constants.java` | âœ… å®Œæˆ | 100% | å…¨å±€å¸¸é‡å®šä¹‰ |
| `ModConfig.java` | âœ… å®Œæˆ | 95% | é…ç½®ç³»ç»Ÿæ ¸å¿ƒç®¡ç† |
| `ConfigData.java` | âœ… å®Œæˆ | 100% | å®Œæ•´é…ç½®æ•°æ®æ¨¡å‹ |
| `ConfigManager.java` | âœ… å®Œæˆ | 95% | **æ–°å¢** - é…ç½®æ–‡ä»¶æŒä¹…åŒ–ç®¡ç† |
| `StatisticsCollector.java` | âœ… å®Œæˆ | 90% | **æ–°å¢** - ç»Ÿè®¡æ•°æ®æ”¶é›†å’Œå­˜å‚¨ |
| `ModInitializer.java` | âœ… å®Œæˆ | 85% | **æ–°å¢** - ç³»ç»Ÿåˆå§‹åŒ–åè°ƒå™¨ |
| `AsyncTaskManager.java` | âœ… å®Œæˆ | 95% | å¼‚æ­¥ä»»åŠ¡ç®¡ç†ï¼Œå¤šçº¿ç¨‹æ± æ¶æ„ |
| `SmartTaskManager.java` | âœ… å®Œæˆ | 90% | æ™ºèƒ½ä»»åŠ¡è°ƒåº¦å’Œæ‰§è¡Œ |
| `TaskQueue.java` | âœ… å®Œæˆ | 100% | ä¼˜å…ˆçº§ä»»åŠ¡é˜Ÿåˆ— |
| `UndoManager.java` | âœ… å®Œæˆ | 95% | å®Œæ•´æ’¤é”€ç³»ç»Ÿ |
| `TaskHistoryManager.java` | âœ… å®Œæˆ | 95% | ä»»åŠ¡å†å²å’Œæ€§èƒ½ç»Ÿè®¡ |
| `EntityCleaner.java` | âœ… å®Œæˆ | 90% | å®ä½“æ¸…ç†æ ¸å¿ƒå¼•æ“ |
| `MiniHUDConfigScreen.java` | âœ… å®Œæˆ | 85% | **ä¸»é…ç½®ç•Œé¢å·²å®ç°** |
| `ConfigCategoryRenderer.java` | âœ… å®Œæˆ | 90% | **GUIæ¸²æŸ“ç³»ç»Ÿå·²å®ç°** |
| `PacketHandler.java` | âœ… å®Œæˆ | 80% | **ç½‘ç»œé€šä¿¡æ ¸å¿ƒå·²å®ç°** |
| `PerformanceMonitor.java` | âœ… å®Œæˆ | 90% | **æ€§èƒ½ç›‘æ§ç³»ç»Ÿå·²å®ç°** |
| **æ¸…ç†ç³»ç»Ÿ** | âœ… å®Œæˆ | 90% | |
| - `CleaningRequest.java` | âœ… å®Œæˆ | 100% | æ¸…ç†è¯·æ±‚å°è£… |
| - `CleaningResult.java` | âœ… å®Œæˆ | 95% | æ¸…ç†ç»“æœç»Ÿè®¡ |
| - `EntityRemovalInfo.java` | âœ… å®Œæˆ | 85% | å®ä½“ç§»é™¤ä¿¡æ¯ |
| **è¿‡æ»¤å™¨ç³»ç»Ÿ** | âœ… å®Œæˆ | 85% | |
| - `ItemEntityFilter.java` | âœ… å®Œæˆ | 85% | ç‰©å“å®ä½“è¿‡æ»¤ |
| - `AnimalDensityFilter.java` | âœ… å®Œæˆ | 85% | åŠ¨ç‰©å¯†åº¦è¿‡æ»¤ |
| - `CustomFilter.java` | âœ… å®Œæˆ | 90% | è‡ªå®šä¹‰è¿‡æ»¤å™¨ |
| **ç­–ç•¥ç³»ç»Ÿ** | âœ… å®Œæˆ | 80% | |
| - `CleaningStrategy.java` | âœ… å®Œæˆ | 100% | ç­–ç•¥æ¥å£ |
| - `TimeBasedStrategy.java` | âœ… å®Œæˆ | 80% | æ—¶é—´ç­–ç•¥ |
| - `DistanceBasedStrategy.java` | âœ… å®Œæˆ | 80% | è·ç¦»ç­–ç•¥ |
| - `DensityBasedStrategy.java` | âœ… å®Œæˆ | 85% | å¯†åº¦ç­–ç•¥ |
| **ç½‘ç»œæ•°æ®åŒ…** | âœ… å®Œæˆ | 80% | |
| - `ConfigSyncPacket.java` | âœ… å®Œæˆ | 80% | é…ç½®åŒæ­¥ |
| - `TaskStatusPacket.java` | âœ… å®Œæˆ | 80% | ä»»åŠ¡çŠ¶æ€ |
| - `CleaningStatusPacket.java` | âœ… å®Œæˆ | 80% | æ¸…ç†çŠ¶æ€ |
| - `UndoRequestPacket.java` | âœ… å®Œæˆ | 80% | æ’¤é”€è¯·æ±‚ |
| - `StatisticsPacket.java` | âœ… å®Œæˆ | 80% | ç»Ÿè®¡æ•°æ® |

---

## ğŸš¨ å½“å‰æŠ€æœ¯å€ºåŠ¡

### âš¡ **ç´§æ€¥ä¿®å¤é¡¹ - é˜»ç¢ç¼–è¯‘è¿è¡Œ**

#### 1. **Minecraft 1.20.1 APIå…¼å®¹æ€§é—®é¢˜**
- `chunk.getEntities()` â†’ éœ€è¦æ›´æ–°åˆ°æ–°çš„API
- `entity.getLevel()` â†’ è®¿é—®æƒé™é—®é¢˜
- `Screen.font` â†’ GUIå­—ä½“è®¿é—®æ–¹å¼å˜æ›´
- `ChunkMap.getUpdatingChunkIfPresent()` â†’ protectedæƒé™é™åˆ¶

#### 2. **ç¼ºå¤±æ–¹æ³•å®ç°**
- `CleaningResult` ç±»éœ€è¦æ·»åŠ  `setItemsRemoved()` å’Œ `setAnimalsRemoved()` æ–¹æ³•
- `AnimalCleaningConfig` éœ€è¦æ·»åŠ  `strategy` å­—æ®µæ”¯æŒ

#### 3. **GSONä¾èµ–é…ç½®é—®é¢˜**
- ç¼–è¯‘æ—¶å¯ç”¨ä½†è¿è¡Œæ—¶è§£æé”™è¯¯

---
| `TaskStatus.java` | âœ… å®Œæˆ | 100% | ä»»åŠ¡çŠ¶æ€æšä¸¾ |
| `TaskExecution.java` | âœ… å®Œæˆ | 100% | ä»»åŠ¡æ‰§è¡Œä¿¡æ¯æ¨¡å‹ |
| `TaskResult.java` | âœ… å®Œæˆ | 100% | ä»»åŠ¡æ‰§è¡Œç»“æœæ¨¡å‹ |
| `EntityCleaner.java` | âœ… å®Œæˆ | 90% | å®ä½“æ¸…ç†æ ¸å¿ƒé€»è¾‘ âœ¨ **æ–°å¢** |
| `CleaningRequest.java` | âœ… å®Œæˆ | 100% | æ¸…ç†è¯·æ±‚å°è£…ç±» âœ¨ **æ–°å¢** |
| `CleaningResult.java` | âœ… å®Œæˆ | 100% | æ¸…ç†ç»“æœå°è£…ç±» âœ¨ **æ–°å¢** |
| `EntityRemovalInfo.java` | âœ… å®Œæˆ | 85% | å®ä½“ç§»é™¤ä¿¡æ¯è®°å½• âœ¨ **æ–°å¢** |
| `ItemEntityFilter.java` | âœ… å®Œæˆ | 85% | ç‰©å“å®ä½“è¿‡æ»¤å™¨ âœ¨ **æ–°å¢** |
| `AnimalDensityFilter.java` | âœ… å®Œæˆ | 85% | åŠ¨ç‰©å¯†åº¦è¿‡æ»¤å™¨ âœ¨ **æ–°å¢** |
| `CustomFilter.java` | âœ… å®Œæˆ | 90% | è‡ªå®šä¹‰è¿‡æ»¤å™¨ âœ¨ **æ–°å¢** |
| `CleaningStrategy.java` | âœ… å®Œæˆ | 100% | æ¸…ç†ç­–ç•¥æ¥å£ âœ¨ **æ–°å¢** |
| `TimeBasedStrategy.java` | âœ… å®Œæˆ | 80% | åŸºäºæ—¶é—´çš„æ¸…ç†ç­–ç•¥ âœ¨ **æ–°å¢** |
| `DistanceBasedStrategy.java` | âœ… å®Œæˆ | 80% | åŸºäºè·ç¦»çš„æ¸…ç†ç­–ç•¥ âœ¨ **æ–°å¢** |
| `DensityBasedStrategy.java` | âœ… å®Œæˆ | 85% | åŸºäºå¯†åº¦çš„æ¸…ç†ç­–ç•¥ âœ¨ **æ–°å¢** |
| `SafeEntityAccess.java` | âœ… å®Œæˆ | 85% | çº¿ç¨‹å®‰å…¨å®ä½“è®¿é—® âœ¨ **æ–°å¢** |
| `build.gradle` | âœ… å®Œæˆ | 100% | Gradleæ„å»ºé…ç½® |
| `gradle.properties` | âœ… å®Œæˆ | 100% | é¡¹ç›®å±æ€§é…ç½® |
| `mods.toml` | âœ… å®Œæˆ | 100% | Forgeæ¨¡ç»„å…ƒæ•°æ® |

### å¾…å®ç°æ ¸å¿ƒæ–‡ä»¶ âŒ

- `MiniHUDConfigScreen.java` - é…ç½®ç•Œé¢
- `PacketHandler.java` - ç½‘ç»œé€šä¿¡
- `PerformanceMonitor.java` - æ€§èƒ½ç›‘æ§
- `ChunkProcessor.java` - åŒºå—å¤„ç†å™¨
- `WorldDataManager.java` - ä¸–ç•Œæ•°æ®ç®¡ç†
- `StatisticsCollector.java` - ç»Ÿè®¡æ•°æ®æ”¶é›†

---

## ï¿½ğŸ“‹ æ€»ä½“å¼€å‘ä»»åŠ¡æ¸…å•

### ğŸ”§ æ ¸å¿ƒç³»ç»Ÿå¼€å‘
#### âš¡ æ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ
- [x] **SmartTaskManager æ ¸å¿ƒå®ç°** âœ…
  - [x] ä»»åŠ¡æäº¤ä¸æ‰§è¡Œæœºåˆ¶
  - [x] ä¼˜å…ˆçº§é˜Ÿåˆ—ç®¡ç†
  - [x] ä»»åŠ¡çŠ¶æ€è¿½è¸ª
  - [x] çº¿ç¨‹å®‰å…¨å¤„ç†
- [x] **UndoManager æ’¤é”€ç³»ç»Ÿ** âœ…
  - [x] æ’¤é”€æ•°æ®æ”¶é›†ä¸å­˜å‚¨
  - [x] å®ä½“NBTæ•°æ®ä¿å­˜
  - [x] å®‰å…¨çš„å®ä½“æ¢å¤æœºåˆ¶
  - [x] æ’¤é”€æ“ä½œè¶…æ—¶å¤„ç†
- [x] **TaskQueue ä»»åŠ¡é˜Ÿåˆ—** âœ…
  - [x] ä¼˜å…ˆçº§æ’åºç®—æ³•
  - [x] ä»»åŠ¡æš‚åœ/æ¢å¤æœºåˆ¶
  - [x] é˜Ÿåˆ—çŠ¶æ€ç›‘æ§
- [x] **TaskHistoryManager å†å²è®°å½•** âœ…
  - [x] ä»»åŠ¡æ‰§è¡Œå†å²å­˜å‚¨
  - [x] æ€§èƒ½æ•°æ®ç»Ÿè®¡
  - [x] å†å²æ•°æ®æ¸…ç†æœºåˆ¶

#### ğŸ§¹ å®ä½“æ¸…ç†ç³»ç»Ÿ
- [x] **EntityCleaner æ¸…ç†æ ¸å¿ƒ** âœ…
  - [x] å¼‚æ­¥æ¸…ç†ä»»åŠ¡æ‰§è¡Œ
  - [x] å¤šçº¿ç¨‹å®‰å…¨è®¾è®¡
  - [x] æ¸…ç†ç»“æœç»Ÿè®¡
- [x] **æ¸…ç†è¿‡æ»¤å™¨å¼€å‘** âœ…
  - [x] ItemEntityFilter (ç‰©å“è¿‡æ»¤)
  - [x] AnimalDensityFilter (åŠ¨ç‰©å¯†åº¦è¿‡æ»¤)
  - [x] CustomFilter (è‡ªå®šä¹‰è¿‡æ»¤å™¨)
- [x] **æ¸…ç†ç­–ç•¥å®ç°** âœ…
  - [x] TimeBasedStrategy (æ—¶é—´ç­–ç•¥)
  - [x] DistanceBasedStrategy (è·ç¦»ç­–ç•¥)
  - [x] DensityBasedStrategy (å¯†åº¦ç­–ç•¥)
- [x] **SafeEntityAccess å®‰å…¨è®¿é—®** âœ…
  - [x] çº¿ç¨‹å®‰å…¨çš„å®ä½“è·å–
  - [x] å®‰å…¨çš„å®ä½“åˆ é™¤æœºåˆ¶
  - [x] å®ä½“çŠ¶æ€éªŒè¯

#### âš™ï¸ å¼‚æ­¥å¤„ç†æ¶æ„
- [x] **AsyncTaskManager ä»»åŠ¡ç®¡ç†** âœ…
  - [x] å¤šçº¿ç¨‹æ± è®¾è®¡ (æ ¸å¿ƒ/IO/è°ƒåº¦)
  - [x] ä»»åŠ¡æäº¤ä¸è°ƒåº¦
  - [x] çº¿ç¨‹æ± ç›‘æ§ä¸è°ƒä¼˜
  - [x] ä¼˜é›…å…³é—­æœºåˆ¶
- [ ] **ChunkProcessor åŒºå—å¤„ç†**
  - [ ] åˆ†å—å¼‚æ­¥å¤„ç†
  - [ ] åŒºå—è´Ÿè½½å‡è¡¡
  - [ ] å¤„ç†è¿›åº¦è¿½è¸ª
- [ ] **ThreadSafeCounter çº¿ç¨‹å®‰å…¨è®¡æ•°**
  - [ ] åŸå­æ“ä½œè®¡æ•°å™¨
  - [ ] ç»Ÿè®¡æ•°æ®æ”¶é›†
  - [ ] æ€§èƒ½æŒ‡æ ‡è¿½è¸ª

### ğŸ¨ ç”¨æˆ·ç•Œé¢å¼€å‘
#### ğŸ“± MiniHUDé£æ ¼é…ç½®ç•Œé¢
- [ ] **MiniHUDConfigScreen ä¸»ç•Œé¢**
  - [ ] ä¾§è¾¹æ åˆ†ç±»å¯¼èˆª
  - [ ] å†…å®¹åŒºåŸŸæ»šåŠ¨é¢æ¿
  - [ ] å®æ—¶ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
  - [ ] å“åº”å¼å¸ƒå±€è®¾è®¡
- [ ] **é…ç½®ç»„ä»¶ç³»ç»Ÿ**
  - [ ] AbstractConfigWidget æŠ½è±¡åŸºç±»
  - [ ] BooleanToggleWidget å¼€å…³ç»„ä»¶
  - [ ] NumberSliderWidget æ»‘å—ç»„ä»¶
  - [ ] StringListConfigEntry åˆ—è¡¨ç»„ä»¶
  - [ ] ActionButtonWidget æ“ä½œæŒ‰é’®
  - [ ] UndoHistoryWidget æ’¤é”€å†å²ç»„ä»¶
  - [ ] TaskStatusWidget ä»»åŠ¡çŠ¶æ€ç»„ä»¶

#### ğŸ“‚ é…ç½®åˆ†ç±»ç®¡ç†
- [ ] **ItemCleaningCategory ç‰©å“æ¸…ç†åˆ†ç±»**
  - [ ] å¯ç”¨/ç¦ç”¨å¼€å…³
  - [ ] å­˜æ´»æ—¶é—´è®¾ç½®
  - [ ] åŒºå—é™åˆ¶é…ç½®
  - [ ] ç™½åå•/é»‘åå•ç®¡ç†
- [ ] **AnimalCleaningCategory åŠ¨ç‰©æ¸…ç†åˆ†ç±»**
  - [ ] å¯†åº¦é™åˆ¶è®¾ç½®
  - [ ] æ£€æŸ¥åŠå¾„é…ç½®
  - [ ] ç¹æ®–ä¿æŠ¤é€‰é¡¹
  - [ ] æ’é™¤åŠ¨ç‰©ç±»å‹ç®¡ç†
- [ ] **TaskManagementCategory ä»»åŠ¡ç®¡ç†åˆ†ç±»**
  - [ ] æ’¤é”€æ“ä½œç•Œé¢
  - [ ] ä»»åŠ¡å†å²æŸ¥çœ‹
  - [ ] ä»»åŠ¡çŠ¶æ€ç›‘æ§
  - [ ] æš‚åœ/æ¢å¤æ§åˆ¶
- [ ] **PerformanceCategory æ€§èƒ½è®¾ç½®åˆ†ç±»**
  - [ ] çº¿ç¨‹æ± é…ç½®
  - [ ] å†…å­˜é˜ˆå€¼è®¾ç½®
  - [ ] å¤„ç†é€Ÿåº¦è°ƒèŠ‚
  - [ ] ç´§æ€¥æ¸…ç†é…ç½®

#### âŒ¨ï¸ äº¤äº’ä½“éªŒä¼˜åŒ–
- [ ] **å¿«æ·é”®ç³»ç»Ÿ**
  - [ ] CONFIG_KEY (æ‰“å¼€é…ç½®)
  - [ ] TOGGLE_KEY (å¼€å…³åŠŸèƒ½)
  - [ ] UNDO_KEY (å¿«é€Ÿæ’¤é”€)
  - [ ] è‡ªå®šä¹‰æŒ‰é”®ç»‘å®š
- [ ] **HUDä¿¡æ¯æ˜¾ç¤º**
  - [ ] å®æ—¶çŠ¶æ€æ˜¾ç¤º
  - [ ] ç»Ÿè®¡æ•°æ®å±•ç¤º
  - [ ] ä»»åŠ¡è¿›åº¦æç¤º
  - [ ] å¿«æ·é”®å¸®åŠ©

### ğŸŒ ç½‘ç»œä¸æ•°æ®ç³»ç»Ÿ
#### ğŸ“¡ ç½‘ç»œé€šä¿¡
- [ ] **PacketHandler æ•°æ®åŒ…å¤„ç†**
  - [ ] å®¢æˆ·ç«¯-æœåŠ¡å™¨åŒæ­¥
  - [ ] é…ç½®å˜æ›´å¹¿æ’­
  - [ ] å®æ—¶çŠ¶æ€æ›´æ–°
- [ ] **æ•°æ®åŒ…å®šä¹‰**
  - [ ] ConfigSyncPacket (é…ç½®åŒæ­¥)
  - [ ] TaskStatusPacket (ä»»åŠ¡çŠ¶æ€)
  - [ ] UndoRequestPacket (æ’¤é”€è¯·æ±‚)
  - [ ] CleaningStatusPacket (æ¸…ç†çŠ¶æ€)

#### ğŸ’¾ æ•°æ®æŒä¹…åŒ–
- [x] **ConfigData é…ç½®ç®¡ç†** âœ…
  - [x] JSONé…ç½®æ–‡ä»¶
  - [ ] å®æ—¶é…ç½®åŒæ­¥
  - [ ] é…ç½®ç‰ˆæœ¬å…¼å®¹
- [ ] **WorldDataManager ä¸–ç•Œæ•°æ®**
  - [ ] NBTæ•°æ®å­˜å‚¨
  - [ ] åŒºå—æ¸…ç†æ•°æ®
  - [ ] ç»Ÿè®¡ä¿¡æ¯æŒä¹…åŒ–
- [ ] **StatisticsCollector ç»Ÿè®¡æ”¶é›†**
  - [ ] æ¸…ç†æ“ä½œç»Ÿè®¡
  - [ ] æ€§èƒ½æ•°æ®æ”¶é›†
  - [ ] å†å²æ•°æ®åˆ†æ

### ğŸš€ æ€§èƒ½ä¸ä¼˜åŒ–
#### âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- [ ] **æ™ºèƒ½åˆ†å—å¤„ç†**
  - [ ] åŒºå—è´Ÿè½½è¯„ä¼°
  - [ ] å¤„ç†ä¼˜å…ˆçº§ç®—æ³•
  - [ ] åŠ¨æ€å¹¶å‘è°ƒèŠ‚
- [ ] **å†…å­˜ç®¡ç†ä¼˜åŒ–**
  - [ ] å†…å­˜ä½¿ç”¨ç›‘æ§
  - [ ] æ™ºèƒ½åƒåœ¾å›æ”¶
  - [ ] å¯¹è±¡æ± å¤ç”¨
- [ ] **ç®—æ³•ä¼˜åŒ–**
  - [ ] ç©ºé—´ç½‘æ ¼ç´¢å¼•
  - [ ] å¯†åº¦æ£€æµ‹ç®—æ³•
  - [ ] å®ä½“è¿‡æ»¤ä¼˜åŒ–

#### ğŸ“Š ç›‘æ§ä¸è°ƒè¯•
- [ ] **PerformanceMonitor æ€§èƒ½ç›‘æ§**
  - [ ] å®æ—¶æ€§èƒ½æŒ‡æ ‡
  - [ ] å†…å­˜ä½¿ç”¨è¿½è¸ª
  - [ ] æ¸…ç†æ•ˆç‡ç»Ÿè®¡
- [ ] **ErrorHandler é”™è¯¯å¤„ç†**
  - [ ] å¼‚å¸¸åˆ†ç±»å¤„ç†
  - [ ] è‡ªåŠ¨æ¢å¤æœºåˆ¶
  - [ ] é”™è¯¯æ—¥å¿—è®°å½•
- [ ] **LogAnalyzer æ—¥å¿—åˆ†æ**
  - [ ] æ€§èƒ½æ—¥å¿—è§£æ
  - [ ] ç“¶é¢ˆè¯†åˆ«
  - [ ] ä¼˜åŒ–å»ºè®®ç”Ÿæˆ

### ğŸ”§ å…¼å®¹æ€§ä¸æ‰©å±•
#### ğŸ”Œ APIè®¾è®¡
- [ ] **ArisSweepingAPI å…¬å…±æ¥å£**
  - [ ] æ’ä»¶æ³¨å†Œæœºåˆ¶
  - [ ] è‡ªå®šä¹‰ç­–ç•¥æ”¯æŒ
  - [ ] é…ç½®ç›‘å¬å™¨
  - [ ] ç»Ÿè®¡æ•°æ®è®¿é—®
- [ ] **PluginManager æ’ä»¶ç³»ç»Ÿ**
  - [ ] æ’ä»¶åŠ è½½å™¨
  - [ ] æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
  - [ ] æ’ä»¶é—´é€šä¿¡
  - [ ] æ’ä»¶é…ç½®ç®¡ç†

#### ğŸ§ª æµ‹è¯•ä¸è´¨é‡ä¿è¯
- [ ] **å•å…ƒæµ‹è¯•**
  - [ ] å®ä½“æ¸…ç†åŠŸèƒ½æµ‹è¯•
  - [ ] çº¿ç¨‹å®‰å…¨æµ‹è¯•
  - [ ] é…ç½®ç³»ç»Ÿæµ‹è¯•
  - [ ] APIæ¥å£æµ‹è¯•
- [ ] **é›†æˆæµ‹è¯•**
  - [ ] å®Œæ•´æ¸…ç†æµç¨‹æµ‹è¯•
  - [ ] å¤šçº¿ç¨‹å¹¶å‘æµ‹è¯•
  - [ ] æ€§èƒ½å‹åŠ›æµ‹è¯•
  - [ ] å…¼å®¹æ€§æµ‹è¯•

### ï¿½ æ•°æ®æ¨¡å‹ä¸æšä¸¾ç±» âœ…
#### ğŸ¯ ä»»åŠ¡ç›¸å…³æ¨¡å‹
- [x] **TaskExecution ä»»åŠ¡æ‰§è¡Œä¿¡æ¯** âœ…
  - [x] ä»»åŠ¡çŠ¶æ€è¿½è¸ª
  - [x] æ‰§è¡Œæ—¶é•¿ç»Ÿè®¡
  - [x] è¿›åº¦ç®¡ç†
  - [x] å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸæ”¯æŒ
- [x] **TaskResult ä»»åŠ¡æ‰§è¡Œç»“æœ** âœ…
  - [x] æˆåŠŸ/å¤±è´¥çŠ¶æ€
  - [x] æ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
  - [x] é”™è¯¯ä¿¡æ¯è®°å½•
  - [x] é™æ€å·¥å‚æ–¹æ³•

#### ğŸ”¢ æšä¸¾ç±»å®šä¹‰
- [x] **TaskPriority ä»»åŠ¡ä¼˜å…ˆçº§** âœ…
  - [x] LOW/NORMAL/HIGH/CRITICAL å››çº§ä¼˜å…ˆçº§
  - [x] ä¼˜å…ˆçº§æ¯”è¾ƒæ–¹æ³•
  - [x] æ•°å€¼çº§åˆ«æ”¯æŒ
- [x] **TaskStatus ä»»åŠ¡çŠ¶æ€** âœ…
  - [x] PENDING/RUNNING/COMPLETED ç­‰8ç§çŠ¶æ€
  - [x] çŠ¶æ€æ£€æŸ¥æ–¹æ³•
  - [x] ç”Ÿå‘½å‘¨æœŸç®¡ç†

### ï¿½ğŸ“¦ éƒ¨ç½²ä¸ç»´æŠ¤
#### ğŸ—ï¸ æ„å»ºä¸å‘å¸ƒ
- [x] **build.gradle æ„å»ºé…ç½®** âœ…
  - [x] Forgeç‰ˆæœ¬é…ç½®
  - [x] ä¾èµ–ç®¡ç†
  - [x] æ„å»ºè„šæœ¬ä¼˜åŒ–
  - [x] èµ„æºå¤„ç†é…ç½®
- [x] **gradle.properties å±æ€§é…ç½®** âœ…
  - [x] æ¨¡ç»„å…ƒä¿¡æ¯
  - [x] ç‰ˆæœ¬ç®¡ç†
  - [x] æ„å»ºå‚æ•°
- [x] **mods.toml æ¨¡ç»„é…ç½®** âœ…
  - [x] æ¨¡ç»„æè¿°ä¿¡æ¯
  - [x] ä¾èµ–å£°æ˜
  - [x] åŠ è½½å™¨é…ç½®
  - [ ] ä¾èµ–ç®¡ç†
  - [ ] æ„å»ºè„šæœ¬ä¼˜åŒ–
  - [ ] è‡ªåŠ¨åŒ–æµ‹è¯•é›†æˆ
  - [ ] å‘å¸ƒæµç¨‹è‡ªåŠ¨åŒ–
- [ ] **ç‰ˆæœ¬ç®¡ç†**
  - [ ] è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
  - [ ] å˜æ›´æ—¥å¿—ç»´æŠ¤
  - [ ] å‘åå…¼å®¹æ€§ä¿è¯

#### ğŸ” æ•…éšœæ’é™¤ä¸ç»´æŠ¤
- [ ] **æ•…éšœæ’é™¤æŒ‡å—**
  - [ ] å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ
  - [ ] æ€§èƒ½è°ƒä¼˜æŒ‡å—
  - [ ] è°ƒè¯•å·¥å…·ä½¿ç”¨
- [ ] **ç”¨æˆ·æ–‡æ¡£**
  - [ ] å®‰è£…é…ç½®æŒ‡å—
  - [ ] åŠŸèƒ½ä½¿ç”¨è¯´æ˜
  - [ ] æœ€ä½³å®è·µæ¨è

---

### ğŸ“Š å¼€å‘è¿›åº¦ç»Ÿè®¡
- **æ€»ä½“è¿›åº¦**: 70% (å¤§å¹…æå‡ï¼) â¬†ï¸
- **æ ¸å¿ƒç³»ç»Ÿ**: 85% â¬†ï¸
- **ç”¨æˆ·ç•Œé¢**: 0%
- **ç½‘ç»œæ•°æ®**: 0%
- **æ€§èƒ½ä¼˜åŒ–**: 0%
- **æµ‹è¯•è´¨é‡**: 0%

### ğŸ¯ å¼€å‘é‡Œç¨‹ç¢‘
1. **Alpha 0.1**: åŸºç¡€å®ä½“æ¸…ç†åŠŸèƒ½ âœ… **å®Œæˆï¼**
2. **Alpha 0.2**: æ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ âœ… **å®Œæˆï¼**
3. **Beta 0.3**: å®Œæ•´æ’¤é”€ç³»ç»Ÿ âœ… **å®Œæˆï¼**
4. **Beta 0.4**: MiniHUDé£æ ¼é…ç½®ç•Œé¢ â³ **ä¸‹ä¸€æ­¥**
5. **RC 0.9**: æ€§èƒ½ä¼˜åŒ–ä¸ç¨³å®šæ€§æ”¹è¿›
6. **Release 1.0**: æ­£å¼ç‰ˆæœ¬å‘å¸ƒ

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 åŠŸèƒ½éœ€æ±‚
- **ä¸»è¦åŠŸèƒ½**: å¼‚æ­¥æ¸…ç†æ‰è½ç‰©å’Œè¿‡å¯†ç•œç‰§å®ä½“
- **é…ç½®ç³»ç»Ÿ**: æ¸¸æˆå†…å¯è§†åŒ–é…ç½®ç•Œé¢
- **æ€§èƒ½è¦æ±‚**: ä¸å½±å“æ¸¸æˆä¸»çº¿ç¨‹æ€§èƒ½
- **å…¼å®¹æ€§**: æ”¯æŒå•äººå’Œå¤šäººæ¸¸æˆ

### 1.2 æŠ€æœ¯æ ˆ
- **æ ¸å¿ƒæ¡†æ¶**: MinecraftForge 1.20.1
- **UIæ¡†æ¶**: ForgeåŸç”ŸGUIç³»ç»Ÿ + è‡ªå®šä¹‰ç»„ä»¶
- **å¼‚æ­¥å¤„ç†**: CompletableFuture + è‡ªå®šä¹‰çº¿ç¨‹æ± 
- **é…ç½®ç®¡ç†**: Forge Configuration API + JSONåºåˆ—åŒ–
- **æ•°æ®å­˜å‚¨**: NBT + ä¸–ç•Œæ•°æ®æŒä¹…åŒ–

---

## 2. é¡¹ç›®ç»“æ„è®¾è®¡

### 2.1 åŒ…ç»“æ„
```
com.arisweeping
â”œâ”€â”€ core/                          # æ ¸å¿ƒæ¨¡å—
â”‚   â”œâ”€â”€ ArisSweepingMod.java      # ä¸»æ¨¡ç»„ç±»
â”‚   â”œâ”€â”€ ModConfig.java            # é…ç½®ç®¡ç†
â”‚   â””â”€â”€ Constants.java            # å¸¸é‡å®šä¹‰
â”œâ”€â”€ tasks/                         # æ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ (æ–°å¢)
â”‚   â”œâ”€â”€ SmartTaskManager.java     # æ™ºèƒ½ä»»åŠ¡ç®¡ç†å™¨
â”‚   â”œâ”€â”€ UndoManager.java          # æ’¤é”€ç®¡ç†å™¨
â”‚   â”œâ”€â”€ TaskQueue.java            # ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†
â”‚   â”œâ”€â”€ TaskHistoryManager.java   # ä»»åŠ¡å†å²ç®¡ç†
â”‚   â”œâ”€â”€ models/                   # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ TaskExecution.java
â”‚   â”‚   â”œâ”€â”€ UndoData.java
â”‚   â”‚   â”œâ”€â”€ EntityRestoreData.java
â”‚   â”‚   â”œâ”€â”€ TaskResult.java
â”‚   â”‚   â””â”€â”€ UndoResult.java
â”‚   â””â”€â”€ enums/                    # æšä¸¾å®šä¹‰
â”‚       â”œâ”€â”€ TaskPriority.java
â”‚       â””â”€â”€ TaskStatus.java
â”œâ”€â”€ cleaning/                      # æ¸…ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ EntityCleaner.java        # å®ä½“æ¸…ç†æ ¸å¿ƒ
â”‚   â”œâ”€â”€ CleaningTask.java         # æ¸…ç†ä»»åŠ¡å°è£…
â”‚   â”œâ”€â”€ filters/                  # æ¸…ç†è¿‡æ»¤å™¨
â”‚   â”‚   â”œâ”€â”€ ItemEntityFilter.java
â”‚   â”‚   â”œâ”€â”€ AnimalDensityFilter.java
â”‚   â”‚   â””â”€â”€ CustomFilter.java
â”‚   â””â”€â”€ strategies/               # æ¸…ç†ç­–ç•¥
â”‚       â”œâ”€â”€ TimeBasedStrategy.java
â”‚       â”œâ”€â”€ DistanceBasedStrategy.java
â”‚       â””â”€â”€ DensityBasedStrategy.java
â”œâ”€â”€ async/                        # å¼‚æ­¥å¤„ç†
â”‚   â”œâ”€â”€ AsyncTaskManager.java     # ä»»åŠ¡ç®¡ç†å™¨
â”‚   â”œâ”€â”€ ThreadSafeCounter.java    # çº¿ç¨‹å®‰å…¨è®¡æ•°å™¨
â”‚   â”œâ”€â”€ ChunkProcessor.java       # åŒºå—å¤„ç†å™¨
â”‚   â””â”€â”€ SafeEntityAccess.java     # å®‰å…¨å®ä½“è®¿é—®
â”œâ”€â”€ gui/                          # ç”¨æˆ·ç•Œé¢
â”‚   â”œâ”€â”€ ConfigScreen.java         # ä¸»é…ç½®ç•Œé¢
â”‚   â”œâ”€â”€ components/               # UIç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ EntityFilterWidget.java
â”‚   â”‚   â”œâ”€â”€ SliderWidget.java
â”‚   â”‚   â”œâ”€â”€ ToggleButton.java
â”‚   â”‚   â”œâ”€â”€ ProgressBar.java
â”‚   â”‚   â”œâ”€â”€ ActionButtonWidget.java      # æ“ä½œæŒ‰é’®ç»„ä»¶ (æ–°å¢)
â”‚   â”‚   â”œâ”€â”€ UndoHistoryWidget.java       # æ’¤é”€å†å²ç»„ä»¶ (æ–°å¢)
â”‚   â”‚   â””â”€â”€ TaskStatusWidget.java        # ä»»åŠ¡çŠ¶æ€ç»„ä»¶ (æ–°å¢)
â”‚   â”œâ”€â”€ categories/               # é…ç½®åˆ†ç±» (æ–°å¢)
â”‚   â”‚   â”œâ”€â”€ TaskManagementCategory.java
â”‚   â”‚   â”œâ”€â”€ ItemCleaningCategory.java
â”‚   â”‚   â””â”€â”€ AnimalCleaningCategory.java
â”‚   â””â”€â”€ handlers/                 # äº‹ä»¶å¤„ç†
â”‚       â”œâ”€â”€ GuiEventHandler.java
â”‚       â””â”€â”€ KeyBindHandler.java
â”œâ”€â”€ network/                      # ç½‘ç»œé€šä¿¡
â”‚   â”œâ”€â”€ PacketHandler.java        # æ•°æ®åŒ…å¤„ç†
â”‚   â”œâ”€â”€ packets/                  # æ•°æ®åŒ…å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ ConfigSyncPacket.java
â”‚   â”‚   â”œâ”€â”€ CleaningStatusPacket.java
â”‚   â”‚   â”œâ”€â”€ EntityCountPacket.java
â”‚   â”‚   â”œâ”€â”€ TaskStatusPacket.java       # ä»»åŠ¡çŠ¶æ€åŒæ­¥åŒ… (æ–°å¢)
â”‚   â”‚   â””â”€â”€ UndoRequestPacket.java      # æ’¤é”€è¯·æ±‚åŒ… (æ–°å¢)
â”‚   â””â”€â”€ NetworkRegistry.java      # ç½‘ç»œæ³¨å†Œ
â”œâ”€â”€ data/                         # æ•°æ®ç®¡ç†
â”‚   â”œâ”€â”€ ConfigData.java           # é…ç½®æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ WorldDataManager.java     # ä¸–ç•Œæ•°æ®ç®¡ç†
â”‚   â””â”€â”€ StatisticsCollector.java  # ç»Ÿè®¡æ•°æ®æ”¶é›†
â””â”€â”€ utils/                        # å·¥å…·ç±»
    â”œâ”€â”€ EntityUtils.java          # å®ä½“å·¥å…·
    â”œâ”€â”€ ChunkUtils.java          # åŒºå—å·¥å…·
    â”œâ”€â”€ MathUtils.java           # æ•°å­¦å·¥å…·
    â””â”€â”€ LoggerUtil.java          # æ—¥å¿—å·¥å…·
```

### 2.2 æ ¸å¿ƒç±»è®¾è®¡

#### 2.2.1 ä¸»æ¨¡ç»„ç±» (ArisSweepingMod.java)
```java
@Mod("arisweeping")
public class ArisSweepingMod {
    public static final String MODID = "arisweeping";
    public static final Logger LOGGER = LogUtils.getLogger();
    
    private static AsyncTaskManager taskManager;
    private static ConfigData configData;
    
    public ArisSweepingMod() {
        // åˆå§‹åŒ–é…ç½®
        ModConfig.initialize();
        // æ³¨å†Œäº‹ä»¶æ€»çº¿
        registerEventHandlers();
        // åˆå§‹åŒ–ç½‘ç»œ
        NetworkRegistry.initialize();
    }
    
    @SubscribeEvent
    public static void onServerStarting(ServerStartingEvent event) {
        taskManager = new AsyncTaskManager();
        // å¯åŠ¨æ¸…ç†ä»»åŠ¡è°ƒåº¦å™¨
        scheduleCleaningTasks();
    }
}
```

---

## 3. æ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ

### 3.1 ä»»åŠ¡ç®¡ç†å™¨æ¶æ„

#### 3.1.1 æ ¸å¿ƒä»»åŠ¡ç®¡ç†å™¨
```java
public class SmartTaskManager {
    private static final int MAX_UNDO_OPERATIONS = 10;
    private static final long UNDO_TIMEOUT_MINUTES = 5;
    
    private final AsyncTaskManager asyncManager;
    private final TaskHistoryManager historyManager;
    private final TaskQueue taskQueue;
    private final UndoManager undoManager;
    
    // ä»»åŠ¡çŠ¶æ€è¿½è¸ª
    private final Map<UUID, TaskExecution> activeTasks = new ConcurrentHashMap<>();
    private final AtomicLong taskIdGenerator = new AtomicLong(0);
    
    public SmartTaskManager() {
        this.asyncManager = new AsyncTaskManager();
        this.historyManager = new TaskHistoryManager();
        this.taskQueue = new TaskQueue();
        this.undoManager = new UndoManager(MAX_UNDO_OPERATIONS, UNDO_TIMEOUT_MINUTES);
    }
    
    /**
     * æäº¤æ¸…ç†ä»»åŠ¡
     */
    public CompletableFuture<TaskResult> submitCleaningTask(CleaningTaskRequest request) {
        UUID taskId = UUID.randomUUID();
        long sequence = taskIdGenerator.incrementAndGet();
        
        TaskExecution execution = new TaskExecution(taskId, sequence, request);
        activeTasks.put(taskId, execution);
        
        return asyncManager.submitTask(() -> {
            try {
                // æ‰§è¡Œæ¸…ç†ä»»åŠ¡
                CleaningResult result = executeCleaningTask(request, taskId);
                
                // è®°å½•ä»»åŠ¡å†å²
                TaskRecord record = new TaskRecord(taskId, request, result, System.currentTimeMillis());
                historyManager.recordTask(record);
                
                // å‡†å¤‡æ’¤é”€æ•°æ®
                if (result.isSuccessful() && result.getRemovedEntities().size() > 0) {
                    UndoData undoData = createUndoData(result);
                    undoManager.registerUndoOperation(taskId, undoData);
                }
                
                return new TaskResult(taskId, result, true);
                
            } catch (Exception e) {
                LOGGER.error("ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", taskId, e);
                return new TaskResult(taskId, null, false, e.getMessage());
            } finally {
                activeTasks.remove(taskId);
            }
        });
    }
    
    /**
     * æ’¤é”€ä¸Šä¸€ä¸ªæ¸…ç†æ“ä½œ
     */
    public CompletableFuture<UndoResult> undoLastOperation() {
        return undoManager.undoLastOperation();
    }
    
    /**
     * æ’¤é”€æŒ‡å®šçš„æ¸…ç†æ“ä½œ
     */
    public CompletableFuture<UndoResult> undoOperation(UUID taskId) {
        return undoManager.undoOperation(taskId);
    }
    
    /**
     * è·å–å¯æ’¤é”€çš„æ“ä½œåˆ—è¡¨
     */
    public List<UndoableOperation> getUndoableOperations() {
        return undoManager.getUndoableOperations();
    }
    
    /**
     * æš‚åœæ‰€æœ‰æ¸…ç†ä»»åŠ¡
     */
    public void pauseAllTasks() {
        taskQueue.pauseAll();
        asyncManager.pauseNonCriticalTasks();
    }
    
    /**
     * æ¢å¤æ‰€æœ‰æ¸…ç†ä»»åŠ¡
     */
    public void resumeAllTasks() {
        taskQueue.resumeAll();
        asyncManager.resumeNonCriticalTasks();
    }
    
    /**
     * è·å–å½“å‰ä»»åŠ¡çŠ¶æ€
     */
    public TaskManagerStatus getStatus() {
        return new TaskManagerStatus(
            activeTasks.size(),
            taskQueue.getQueueSize(),
            undoManager.getUndoableCount(),
            historyManager.getTotalTasksExecuted()
        );
    }
}
```

#### 3.1.2 æ’¤é”€ç®¡ç†å™¨
```java
public class UndoManager {
    private final int maxUndoOperations;
    private final long timeoutMinutes;
    private final LinkedList<UndoableOperation> undoStack = new LinkedList<>();
    private final Map<UUID, UndoData> undoDataMap = new ConcurrentHashMap<>();
    
    public UndoManager(int maxUndoOperations, long timeoutMinutes) {
        this.maxUndoOperations = maxUndoOperations;
        this.timeoutMinutes = timeoutMinutes;
        
        // å®šæœŸæ¸…ç†è¿‡æœŸçš„æ’¤é”€æ•°æ®
        scheduleCleanupTask();
    }
    
    public void registerUndoOperation(UUID taskId, UndoData undoData) {
        synchronized (undoStack) {
            // æ£€æŸ¥å®¹é‡é™åˆ¶
            while (undoStack.size() >= maxUndoOperations) {
                UndoableOperation oldest = undoStack.removeFirst();
                undoDataMap.remove(oldest.getTaskId());
            }
            
            UndoableOperation operation = new UndoableOperation(
                taskId, 
                undoData.getDescription(),
                undoData.getEntityCount(),
                System.currentTimeMillis()
            );
            
            undoStack.addLast(operation);
            undoDataMap.put(taskId, undoData);
        }
    }
    
    public CompletableFuture<UndoResult> undoLastOperation() {
        synchronized (undoStack) {
            if (undoStack.isEmpty()) {
                return CompletableFuture.completedFuture(
                    UndoResult.failure("æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ"));
            }
            
            UndoableOperation lastOp = undoStack.getLast();
            return undoOperation(lastOp.getTaskId());
        }
    }
    
    public CompletableFuture<UndoResult> undoOperation(UUID taskId) {
        UndoData undoData = undoDataMap.get(taskId);
        if (undoData == null) {
            return CompletableFuture.completedFuture(
                UndoResult.failure("æ’¤é”€æ•°æ®ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ"));
        }
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                return performUndo(undoData);
            } catch (Exception e) {
                LOGGER.error("æ‰§è¡Œæ’¤é”€æ“ä½œå¤±è´¥: {}", taskId, e);
                return UndoResult.failure("æ’¤é”€æ“ä½œæ‰§è¡Œå¤±è´¥: " + e.getMessage());
            }
        });
    }
    
    private UndoResult performUndo(UndoData undoData) {
        // è·å–æœåŠ¡å™¨å®ä¾‹çš„æ­£ç¡®æ–¹å¼
        MinecraftServer server = undoData.getEntitiesToRestore().get(0).getLevel().getServer();
        AtomicInteger restoredCount = new AtomicInteger(0);
        AtomicInteger failedCount = new AtomicInteger(0);
        
        // å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œå®ä½“æ¢å¤
        CompletableFuture<Void> undoFuture = CompletableFuture.runAsync(() -> {
            for (EntityRestoreData restoreData : undoData.getEntitiesToRestore()) {
                try {
                    if (restoreEntity(restoreData)) {
                        restoredCount.incrementAndGet();
                    } else {
                        failedCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    LOGGER.warn("æ¢å¤å®ä½“å¤±è´¥: {}", restoreData.getEntityId(), e);
                    failedCount.incrementAndGet();
                }
            }
        }, server::execute);
        
        try {
            undoFuture.get(30, TimeUnit.SECONDS);
            
            // ä»æ’¤é”€æ ˆä¸­ç§»é™¤
            synchronized (undoStack) {
                undoStack.removeIf(op -> op.getTaskId().equals(undoData.getTaskId()));
                undoDataMap.remove(undoData.getTaskId());
            }
            
            return UndoResult.success(restoredCount.get(), failedCount.get());
            
        } catch (TimeoutException e) {
            return UndoResult.failure("æ’¤é”€æ“ä½œè¶…æ—¶");
        } catch (Exception e) {
            return UndoResult.failure("æ’¤é”€æ“ä½œå¤±è´¥: " + e.getMessage());
        }
    }
    
    private boolean restoreEntity(EntityRestoreData restoreData) {
        try {
            ServerLevel level = restoreData.getLevel();
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦å®‰å…¨
            if (!isPositionSafeForRestore(level, restoreData.getPosition())) {
                return false;
            }
            
            // ä»NBTæ•°æ®é‡æ–°åˆ›å»ºå®ä½“
            CompoundTag nbtData = restoreData.getNbtData();
            Optional<Entity> entityOpt = EntityType.create(nbtData, level);
            
            if (entityOpt.isPresent()) {
                Entity entity = entityOpt.get();
                entity.moveTo(restoreData.getPosition());
                level.addFreshEntity(entity);
                return true;
            }
            
        } catch (Exception e) {
            LOGGER.error("æ¢å¤å®ä½“æ—¶å‘ç”Ÿé”™è¯¯", e);
        }
        
        return false;
    }
    
    private boolean isPositionSafeForRestore(ServerLevel level, Vec3 position) {
        BlockPos blockPos = new BlockPos((int) position.x, (int) position.y, (int) position.z);
        
        // æ£€æŸ¥åŒºå—æ˜¯å¦å·²åŠ è½½
        if (!level.isLoaded(blockPos)) {
            return false;
        }
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨ä¸–ç•Œè¾¹ç•Œå†…
        if (!level.getWorldBorder().isWithinBounds(blockPos)) {
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç©ºé—´
        AABB boundingBox = new AABB(position.add(-0.5, 0, -0.5), position.add(0.5, 2, 0.5));
        return level.noBlockCollision(boundingBox);
    }
    
    public List<UndoableOperation> getUndoableOperations() {
        synchronized (undoStack) {
            return new ArrayList<>(undoStack);
        }
    }
    
    public int getUndoableCount() {
        return undoStack.size();
    }
    
    private void scheduleCleanupTask() {
        AsyncTaskManager.getInstance().scheduleAtFixedRate(() -> {
            long cutoffTime = System.currentTimeMillis() - TimeUnit.MINUTES.toMillis(timeoutMinutes);
            
            synchronized (undoStack) {
                undoStack.removeIf(op -> {
                    if (op.getTimestamp() < cutoffTime) {
                        undoDataMap.remove(op.getTaskId());
                        return true;
                    }
                    return false;
                });
            }
        }, 1, 1, TimeUnit.MINUTES);
    }
}
```

#### 3.1.3 æ’¤é”€æ•°æ®ç»“æ„
```java
public class UndoData {
    private final UUID taskId;
    private final String description;
    private final List<EntityRestoreData> entitiesToRestore;
    private final long timestamp;
    
    public UndoData(UUID taskId, String description, List<Entity> removedEntities) {
        this.taskId = taskId;
        this.description = description;
        this.timestamp = System.currentTimeMillis();
        this.entitiesToRestore = createRestoreData(removedEntities);
    }
    
    private List<EntityRestoreData> createRestoreData(List<Entity> entities) {
        List<EntityRestoreData> restoreData = new ArrayList<>();
        
        for (Entity entity : entities) {
            try {
                // ä¿å­˜å®ä½“çš„å®Œæ•´NBTæ•°æ®
                CompoundTag nbtData = new CompoundTag();
                entity.save(nbtData);
                
                EntityRestoreData data = new EntityRestoreData(
                    entity.getId(),
                    entity.getType(),
                    (ServerLevel) entity.level(),
                    entity.position(),
                    nbtData,
                    System.currentTimeMillis()
                );
                
                restoreData.add(data);
                
            } catch (Exception e) {
                LOGGER.warn("æ— æ³•åˆ›å»ºå®ä½“ {} çš„æ’¤é”€æ•°æ®", entity.getId(), e);
            }
        }
        
        return restoreData;
    }
    
    public int getEntityCount() {
        return entitiesToRestore.size();
    }
    
    // Getters...
    public UUID getTaskId() { return taskId; }
    public String getDescription() { return description; }
    public List<EntityRestoreData> getEntitiesToRestore() { return entitiesToRestore; }
    public long getTimestamp() { return timestamp; }
}

public class EntityRestoreData {
    private final int entityId;
    private final EntityType<?> entityType;
    private final ServerLevel level;
    private final Vec3 position;
    private final CompoundTag nbtData;
    private final long captureTime;
    
    public EntityRestoreData(int entityId, EntityType<?> entityType, ServerLevel level, 
                           Vec3 position, CompoundTag nbtData, long captureTime) {
        this.entityId = entityId;
        this.entityType = entityType;
        this.level = level;
        this.position = position;
        this.nbtData = nbtData.copy(); // åˆ›å»ºå‰¯æœ¬é¿å…ä¿®æ”¹åŸæ•°æ®
        this.captureTime = captureTime;
    }
    
    // Getters...
    public int getEntityId() { return entityId; }
    public EntityType<?> getEntityType() { return entityType; }
    public ServerLevel getLevel() { return level; }
    public Vec3 getPosition() { return position; }
    public CompoundTag getNbtData() { return nbtData; }
    public long getCaptureTime() { return captureTime; }
}
```

#### 3.1.4 ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†
```java
public class TaskQueue {
    private final PriorityQueue<QueuedTask> taskQueue = new PriorityQueue<>(
        Comparator.comparing(QueuedTask::getPriority).reversed()
            .thenComparing(QueuedTask::getSubmitTime)
    );
    private final Set<UUID> processingTasks = ConcurrentHashMap.newKeySet();
    private volatile boolean paused = false;
    
    public void submitTask(CleaningTaskRequest request, TaskPriority priority) {
        QueuedTask queuedTask = new QueuedTask(
            UUID.randomUUID(),
            request,
            priority,
            System.currentTimeMillis()
        );
        
        synchronized (taskQueue) {
            taskQueue.offer(queuedTask);
            taskQueue.notifyAll();
        }
    }
    
    public QueuedTask pollNextTask() {
        synchronized (taskQueue) {
            while (!paused && !taskQueue.isEmpty()) {
                QueuedTask task = taskQueue.poll();
                if (task != null && !processingTasks.contains(task.getId())) {
                    processingTasks.add(task.getId());
                    return task;
                }
            }
            return null;
        }
    }
    
    public void markTaskCompleted(UUID taskId) {
        processingTasks.remove(taskId);
    }
    
    public void pauseAll() {
        this.paused = true;
    }
    
    public void resumeAll() {
        synchronized (taskQueue) {
            this.paused = false;
            taskQueue.notifyAll();
        }
    }
    
    public int getQueueSize() {
        return taskQueue.size();
    }
    
    public int getProcessingCount() {
        return processingTasks.size();
    }
}

public enum TaskPriority {
    LOW(1),
    NORMAL(5),
    HIGH(10),
    CRITICAL(20);
    
    private final int value;
    
    TaskPriority(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}
```

---

## 4. å¼‚æ­¥å¤„ç†æ¶æ„

### 4.1 çº¿ç¨‹æ± è®¾è®¡
```java
public class AsyncTaskManager {
    // æ ¸å¿ƒçº¿ç¨‹æ± ï¼šç”¨äºä¸»è¦æ¸…ç†ä»»åŠ¡
    private final ThreadPoolExecutor coreExecutor;
    // IOçº¿ç¨‹æ± ï¼šç”¨äºæ–‡ä»¶è¯»å†™æ“ä½œ
    private final ThreadPoolExecutor ioExecutor;
    // è°ƒåº¦çº¿ç¨‹æ± ï¼šç”¨äºå®šæ—¶ä»»åŠ¡
    private final ScheduledThreadPoolExecutor scheduledExecutor;
    
    public AsyncTaskManager() {
        this.coreExecutor = new ThreadPoolExecutor(
            2, // æ ¸å¿ƒçº¿ç¨‹æ•°
            Math.max(4, Runtime.getRuntime().availableProcessors()), // æœ€å¤§çº¿ç¨‹æ•°
            60L, TimeUnit.SECONDS, // å­˜æ´»æ—¶é—´
            new LinkedBlockingQueue<>(1000), // ä»»åŠ¡é˜Ÿåˆ—
            new ThreadFactory() {
                private final AtomicInteger threadNumber = new AtomicInteger(1);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r, "ArisSweeping-Core-" + threadNumber.getAndIncrement());
                    t.setDaemon(true);
                    return t;
                }
            },
            new ThreadPoolExecutor.CallerRunsPolicy() // æ‹’ç»ç­–ç•¥
        );
        
        this.ioExecutor = Executors.newFixedThreadPool(2, 
            new ThreadFactory() {
                private final AtomicInteger threadNumber = new AtomicInteger(1);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r, "ArisSweeping-IO-" + threadNumber.getAndIncrement());
                    t.setDaemon(true);
                    return t;
                }
            });
            
        this.scheduledExecutor = new ScheduledThreadPoolExecutor(1,
            new ThreadFactory() {
                private final AtomicInteger threadNumber = new AtomicInteger(1);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r, "ArisSweeping-Scheduler-" + threadNumber.getAndIncrement());
                    t.setDaemon(true);
                    return t;
                }
            });
    }
}
```

### 3.2 å¼‚æ­¥ä»»åŠ¡å°è£…
```java
public class CleaningTask implements Callable<CleaningResult> {
    private final ServerLevel level;
    private final ChunkPos chunkPos;
    private final CleaningStrategy strategy;
    private final AtomicBoolean cancelled = new AtomicBoolean(false);
    
    @Override
    public CleaningResult call() throws Exception {
        if (cancelled.get()) return CleaningResult.CANCELLED;
        
        MinecraftServer server = level.getServer();
        
        // åœ¨ä¸»çº¿ç¨‹ä¸­å®‰å…¨è·å–å®ä½“åˆ—è¡¨
        CompletableFuture<List<Entity>> entitiesFuture = 
            CompletableFuture.supplyAsync(() -> 
                SafeEntityAccess.getEntitiesInChunk(level, chunkPos),
                server::execute
            );
        
        List<Entity> entities = entitiesFuture.get(5, TimeUnit.SECONDS);
        
        // åœ¨å·¥ä½œçº¿ç¨‹ä¸­å¤„ç†è¿‡æ»¤é€»è¾‘
        List<Entity> toRemove = strategy.filterEntities(entities);
        
        // å›åˆ°ä¸»çº¿ç¨‹æ‰§è¡Œåˆ é™¤æ“ä½œ
        CompletableFuture<Integer> removeFuture = 
            CompletableFuture.supplyAsync(() -> 
                SafeEntityAccess.removeEntities(level, toRemove),
                server::execute
            );
        
        int removed = removeFuture.get(5, TimeUnit.SECONDS);
        return new CleaningResult(removed, chunkPos);
    }
}
```

---

## 5. çº¿ç¨‹å®‰å…¨è®¾è®¡

### 4.1 å®ä½“å®‰å…¨è®¿é—®
```java
public class SafeEntityAccess {
    private static final Object ENTITY_LOCK = new Object();
    
    public static List<Entity> getEntitiesInChunk(ServerLevel level, ChunkPos pos) {
        // ç¡®ä¿åœ¨æœåŠ¡å™¨çº¿ç¨‹ä¸­æ‰§è¡Œ
        if (!level.getServer().isSameThread()) {
            throw new IllegalStateException("Must be called from server thread");
        }
        
        synchronized (ENTITY_LOCK) {
            LevelChunk chunk = level.getChunk(pos.x, pos.z);
            return new ArrayList<>(chunk.getEntities().getAllEntities());
        }
    }
    
    public static int removeEntities(ServerLevel level, List<Entity> entities) {
        if (!level.getServer().isSameThread()) {
            throw new IllegalStateException("Must be called from server thread");
        }
        
        int removed = 0;
        synchronized (ENTITY_LOCK) {
            for (Entity entity : entities) {
                if (entity.isAlive() && !entity.isRemoved()) {
                    entity.discard();
                    removed++;
                }
            }
        }
        return removed;
    }
}
```

### 4.2 é…ç½®æ•°æ®çº¿ç¨‹å®‰å…¨
```java
public class ConfigData {
    private volatile boolean enabled = true;
    private volatile int itemCleanInterval = 300; // ç§’
    private volatile int animalDensityLimit = 20;
    private final ReadWriteLock configLock = new ReentrantReadWriteLock();
    private final Map<String, Object> dynamicConfig = new ConcurrentHashMap<>();
    
    public boolean isEnabled() {
        configLock.readLock().lock();
        try {
            return enabled;
        } finally {
            configLock.readLock().unlock();
        }
    }
    
    public void setEnabled(boolean enabled) {
        configLock.writeLock().lock();
        try {
            this.enabled = enabled;
            notifyConfigChange();
        } finally {
            configLock.writeLock().unlock();
        }
    }
    
    private void notifyConfigChange() {
        // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨é…ç½®å·²æ›´æ”¹
        EventBus.post(new ConfigChangeEvent(this));
    }
}
```

---

## 6. å¯è§†åŒ–é…ç½®ç³»ç»Ÿ

### 5.1 ä¸»é…ç½®ç•Œé¢è®¾è®¡
```java
public class ConfigScreen extends Screen {
    private static final int GUI_WIDTH = 320;
    private static final int GUI_HEIGHT = 240;
    
    private final ConfigData configData;
    private final List<ConfigWidget> widgets = new ArrayList<>();
    
    // UIç»„ä»¶
    private ToggleButton enabledToggle;
    private SliderWidget intervalSlider;
    private EntityFilterWidget filterWidget;
    private ProgressBar cleaningProgress;
    
    @Override
    protected void init() {
        super.init();
        
        int centerX = this.width / 2;
        int centerY = this.height / 2;
        
        // åˆ›å»ºUIç»„ä»¶
        createToggleButtons(centerX, centerY);
        createSliders(centerX, centerY);
        createFilterWidgets(centerX, centerY);
        createActionButtons(centerX, centerY);
    }
    
    private void createToggleButtons(int centerX, int centerY) {
        enabledToggle = new ToggleButton(
            centerX - 100, centerY - 80, 200, 20,
            Component.literal("å¯ç”¨è‡ªåŠ¨æ¸…ç†"),
            configData.isEnabled(),
            (button, enabled) -> {
                configData.setEnabled(enabled);
                updateDependentWidgets();
            }
        );
        addRenderableWidget(enabledToggle);
    }
}
```

### 5.2 è‡ªå®šä¹‰UIç»„ä»¶
```java
public class SliderWidget extends AbstractSlider {
    private final String labelKey;
    private final int minValue;
    private final int maxValue;
    private final Consumer<Integer> valueConsumer;
    
    public SliderWidget(int x, int y, int width, int height,
                       String labelKey, int currentValue,
                       int minValue, int maxValue,
                       Consumer<Integer> valueConsumer) {
        super(x, y, width, height, 
              Component.literal(labelKey + ": " + currentValue), 
              (double)(currentValue - minValue) / (maxValue - minValue));
        this.labelKey = labelKey;
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.valueConsumer = valueConsumer;
    }
    
    @Override
    protected void updateMessage() {
        int value = getCurrentValue();
        this.setMessage(Component.literal(labelKey + ": " + value));
    }
    
    @Override
    protected void applyValue() {
        valueConsumer.accept(getCurrentValue());
    }
    
    private int getCurrentValue() {
        return (int) (minValue + value * (maxValue - minValue));
    }
}
```

---

## 7. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 6.1 åˆ†å—å¤„ç†
```java
public class ChunkProcessor {
    private static final int MAX_CHUNKS_PER_TICK = 4;
    private final Queue<ChunkPos> processingQueue = new ConcurrentLinkedQueue<>();
    private final Set<ChunkPos> processingChunks = ConcurrentHashMap.newKeySet();
    
    public void scheduleChunkProcessing(ServerLevel level) {
        // é™åˆ¶æ¯tickå¤„ç†çš„åŒºå—æ•°é‡
        int processed = 0;
        while (processed < MAX_CHUNKS_PER_TICK && !processingQueue.isEmpty()) {
            ChunkPos chunkPos = processingQueue.poll();
            if (chunkPos != null && processingChunks.add(chunkPos)) {
                processChunkAsync(level, chunkPos);
                processed++;
            }
        }
    }
    
    private void processChunkAsync(ServerLevel level, ChunkPos chunkPos) {
        AsyncTaskManager.getInstance().submitCoreTask(() -> {
            try {
                CleaningTask task = new CleaningTask(level, chunkPos, getStrategy());
                CleaningResult result = task.call();
                
                // å¤„ç†ç»“æœ
                handleCleaningResult(result);
            } catch (Exception e) {
                LOGGER.error("æ¸…ç†åŒºå—æ—¶å‘ç”Ÿé”™è¯¯: {}", chunkPos, e);
            } finally {
                processingChunks.remove(chunkPos);
            }
        });
    }
}
```

### 6.2 æ™ºèƒ½è¿‡æ»¤ç®—æ³•
```java
public class DensityBasedStrategy implements CleaningStrategy {
    private static final double DENSITY_THRESHOLD = 0.8; // å¯†åº¦é˜ˆå€¼
    private static final int GRID_SIZE = 16; // ç½‘æ ¼å¤§å°
    
    @Override
    public List<Entity> filterEntities(List<Entity> entities) {
        // æŒ‰ç±»å‹åˆ†ç»„
        Map<EntityType<?>, List<Entity>> entityGroups = entities.stream()
            .collect(Collectors.groupingBy(Entity::getType));
        
        List<Entity> toRemove = new ArrayList<>();
        
        for (Map.Entry<EntityType<?>, List<Entity>> entry : entityGroups.entrySet()) {
            EntityType<?> type = entry.getKey();
            List<Entity> typeEntities = entry.getValue();
            
            if (shouldApplyDensityFilter(type)) {
                toRemove.addAll(filterByDensity(typeEntities));
            }
        }
        
        return toRemove;
    }
    
    private List<Entity> filterByDensity(List<Entity> entities) {
        // åˆ›å»ºç©ºé—´ç½‘æ ¼
        Map<GridPos, List<Entity>> grid = createSpatialGrid(entities);
        
        List<Entity> toRemove = new ArrayList<>();
        
        for (Map.Entry<GridPos, List<Entity>> cell : grid.entrySet()) {
            List<Entity> cellEntities = cell.getValue();
            int limit = calculateDensityLimit(cellEntities.size());
            
            if (cellEntities.size() > limit) {
                // ä¿ç•™æœ€æ–°çš„å®ä½“ï¼Œç§»é™¤è¾ƒæ—§çš„
                cellEntities.sort(Comparator.comparingLong(Entity::getId));
                toRemove.addAll(cellEntities.subList(limit, cellEntities.size()));
            }
        }
        
        return toRemove;
    }
}
```

### 6.3 å†…å­˜ç®¡ç†
```java
public class MemoryManager {
    private static final long MAX_HEAP_USAGE = Runtime.getRuntime().maxMemory() * 8 / 10;
    private final ScheduledFuture<?> memoryMonitor;
    
    public MemoryManager() {
        // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡å†…å­˜ä½¿ç”¨æƒ…å†µ
        this.memoryMonitor = AsyncTaskManager.getInstance().scheduleAtFixedRate(
            this::checkMemoryUsage, 30, 30, TimeUnit.SECONDS
        );
    }
    
    private void checkMemoryUsage() {
        long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        if (used > MAX_HEAP_USAGE) {
            LOGGER.warn("å†…å­˜ä½¿ç”¨è¿‡é«˜: {}MB / {}MB", 
                used / 1024 / 1024, 
                Runtime.getRuntime().maxMemory() / 1024 / 1024);
            
            // æš‚åœéå…³é”®ä»»åŠ¡
            AsyncTaskManager.getInstance().pauseNonCriticalTasks();
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            System.gc();
            
            // ç­‰å¾…ä¸€æ®µæ—¶é—´åæ¢å¤ä»»åŠ¡
            AsyncTaskManager.getInstance().scheduleDelayed(() -> {
                AsyncTaskManager.getInstance().resumeNonCriticalTasks();
            }, 5, TimeUnit.SECONDS);
        }
    }
}
```

---

## 8. ç½‘ç»œåŒæ­¥ç³»ç»Ÿ

### 7.1 é…ç½®åŒæ­¥
```java
public class ConfigSyncPacket {
    private final ConfigData configData;
    
    public ConfigSyncPacket(ConfigData configData) {
        this.configData = configData;
    }
    
    public void encode(FriendlyByteBuf buf) {
        buf.writeUtf(configData.toJson());
    }
    
    public static ConfigSyncPacket decode(FriendlyByteBuf buf) {
        String json = buf.readUtf();
        return new ConfigSyncPacket(ConfigData.fromJson(json));
    }
    
    public void handle(Supplier<NetworkEvent.Context> contextSupplier) {
        NetworkEvent.Context context = contextSupplier.get();
        context.enqueueWork(() -> {
            if (context.getDirection() == NetworkDirection.PLAY_TO_CLIENT) {
                // å®¢æˆ·ç«¯æ¥æ”¶æœåŠ¡å™¨é…ç½®
                ClientConfigManager.updateConfig(configData);
            } else if (context.getDirection() == NetworkDirection.PLAY_TO_SERVER) {
                // æœåŠ¡å™¨æ¥æ”¶å®¢æˆ·ç«¯é…ç½®æ›´æ”¹
                ServerPlayer player = context.getSender();
                if (player != null && hasPermission(player)) {
                    ServerConfigManager.updateConfig(configData);
                    // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
                    broadcastConfigUpdate(configData);
                }
            }
        });
        context.setPacketHandled(true);
    }
}
```

---

## 9. é”™è¯¯å¤„ç†å’Œæ—¥å¿—ç³»ç»Ÿ

### 8.1 å¼‚å¸¸å¤„ç†æ¡†æ¶
```java
public class ErrorHandler {
    private static final Map<Class<? extends Exception>, ExceptionHandler> handlers = 
        new ConcurrentHashMap<>();
    
    static {
        registerHandler(EntityAccessException.class, 
            (e, context) -> {
                LOGGER.warn("å®ä½“è®¿é—®å¼‚å¸¸: {}, è·³è¿‡æ­¤æ¬¡æ¸…ç†", e.getMessage());
                return RecoveryAction.SKIP_CURRENT_TASK;
            });
        
        registerHandler(ChunkNotLoadedException.class,
            (e, context) -> {
                LOGGER.debug("åŒºå—æœªåŠ è½½: {}, ç¨åé‡è¯•", e.getMessage());
                return RecoveryAction.RETRY_LATER;
            });
        
        registerHandler(OutOfMemoryError.class,
            (e, context) -> {
                LOGGER.error("å†…å­˜ä¸è¶³ï¼Œè§¦å‘ç´§æ€¥æ¸…ç†", e);
                emergencyCleanup();
                return RecoveryAction.EMERGENCY_STOP;
            });
    }
    
    public static RecoveryAction handleException(Exception e, TaskContext context) {
        ExceptionHandler handler = handlers.get(e.getClass());
        if (handler != null) {
            return handler.handle(e, context);
        }
        
        // é»˜è®¤å¤„ç†
        LOGGER.error("æœªå¤„ç†çš„å¼‚å¸¸", e);
        return RecoveryAction.LOG_AND_CONTINUE;
    }
}
```

### 8.2 è¯¦ç»†æ—¥å¿—è®°å½•
```java
public class LoggerUtil {
    private static final Logger PERFORMANCE_LOGGER = LogManager.getLogger("ArisSweeping-Performance");
    private static final Logger STATISTICS_LOGGER = LogManager.getLogger("ArisSweeping-Statistics");
    
    public static void logCleaningOperation(CleaningResult result) {
        if (result.getRemovedCount() > 0) {
            LOGGER.info("æ¸…ç†å®Œæˆ: åŒºå—{} ç§»é™¤{}ä¸ªå®ä½“, è€—æ—¶{}ms", 
                result.getChunkPos(), 
                result.getRemovedCount(), 
                result.getDurationMs());
        }
        
        // æ€§èƒ½æ—¥å¿—
        if (result.getDurationMs() > 100) {
            PERFORMANCE_LOGGER.warn("æ¸…ç†è€—æ—¶è¿‡é•¿: {}ms at {}", 
                result.getDurationMs(), result.getChunkPos());
        }
    }
    
    public static void logStatistics() {
        StatisticsCollector stats = StatisticsCollector.getInstance();
        STATISTICS_LOGGER.info("ç»Ÿè®¡ä¿¡æ¯: æ€»æ¸…ç†æ¬¡æ•°={}, ç§»é™¤å®ä½“æ•°={}, å¹³å‡è€—æ—¶={}ms",
            stats.getTotalCleanings(),
            stats.getTotalRemovedEntities(),
            stats.getAverageCleaningTime());
    }
}
```

---

## 10. é…ç½®æ–‡ä»¶å’Œæ•°æ®æŒä¹…åŒ–

### 9.1 é…ç½®æ–‡ä»¶ç»“æ„
```json
{
  "version": "1.0.0",
  "general": {
    "enabled": true,
    "debug_mode": false,
    "statistics_collection": true
  },
  "cleaning": {
    "items": {
      "enabled": true,
      "interval_seconds": 300,
      "age_threshold_seconds": 600,
      "max_items_per_chunk": 100,
      "whitelist": ["minecraft:diamond", "minecraft:netherite_ingot"],
      "blacklist": []
    },
    "animals": {
      "enabled": true,
      "density_limit": 20,
      "radius_blocks": 32,
      "excluded_types": ["minecraft:villager", "minecraft:horse"],
      "breeding_protection": true
    }
  },
  "performance": {
    "max_chunks_per_tick": 4,
    "thread_pool_size": 0,
    "memory_threshold_mb": 512,
    "emergency_cleanup": true
  },
  "ui": {
    "keybinding": "key.keyboard.k",
    "show_notifications": true,
    "detailed_statistics": false
  }
}
```

### 9.2 ä¸–ç•Œæ•°æ®ç®¡ç†
```java
public class WorldDataManager extends SavedData {
    private static final String DATA_NAME = "arisweeping_data";
    
    private final Map<ChunkPos, ChunkCleaningData> chunkData = new ConcurrentHashMap<>();
    private final StatisticsData statistics = new StatisticsData();
    
    @Override
    public CompoundTag save(CompoundTag tag) {
        // ä¿å­˜åŒºå—æ•°æ®
        ListTag chunkList = new ListTag();
        for (Map.Entry<ChunkPos, ChunkCleaningData> entry : chunkData.entrySet()) {
            CompoundTag chunkTag = new CompoundTag();
            chunkTag.putLong("pos", entry.getKey().toLong());
            chunkTag.put("data", entry.getValue().toNBT());
            chunkList.add(chunkTag);
        }
        tag.put("chunks", chunkList);
        
        // ä¿å­˜ç»Ÿè®¡æ•°æ®
        tag.put("statistics", statistics.toNBT());
        
        return tag;
    }
    
    public static WorldDataManager load(CompoundTag tag) {
        WorldDataManager manager = new WorldDataManager();
        
        // åŠ è½½åŒºå—æ•°æ®
        ListTag chunkList = tag.getList("chunks", Tag.TAG_COMPOUND);
        for (Tag chunkTag : chunkList) {
            CompoundTag compound = (CompoundTag) chunkTag;
            ChunkPos pos = new ChunkPos(compound.getLong("pos"));
            ChunkCleaningData data = ChunkCleaningData.fromNBT(compound.getCompound("data"));
            manager.chunkData.put(pos, data);
        }
        
        // åŠ è½½ç»Ÿè®¡æ•°æ®
        if (tag.contains("statistics")) {
            manager.statistics.fromNBT(tag.getCompound("statistics"));
        }
        
        return manager;
    }
    
    @Override
    public boolean isDirty() {
        return true; // å§‹ç»ˆä¿å­˜ä»¥ç¡®ä¿æ•°æ®å®‰å…¨
    }
    
    public static WorldDataManager get(ServerLevel level) {
        return level.getDataStorage().computeIfAbsent(
            WorldDataManager::load,
            WorldDataManager::new,
            DATA_NAME
        );
    }
}
```

---

## 11. å…¼å®¹æ€§å’Œæ‰©å±•æ€§

### 10.1 APIè®¾è®¡
```java
public interface ArisSweepingAPI {
    /**
     * æ³¨å†Œè‡ªå®šä¹‰æ¸…ç†ç­–ç•¥
     */
    void registerCleaningStrategy(String id, CleaningStrategy strategy);
    
    /**
     * æ³¨å†Œå®ä½“è¿‡æ»¤å™¨
     */
    void registerEntityFilter(String id, EntityFilter filter);
    
    /**
     * è·å–æ¸…ç†ç»Ÿè®¡ä¿¡æ¯
     */
    CleaningStatistics getStatistics();
    
    /**
     * æ·»åŠ é…ç½®å˜æ›´ç›‘å¬å™¨
     */
    void addConfigChangeListener(ConfigChangeListener listener);
    
    /**
     * ä¸´æ—¶æš‚åœæ¸…ç†ç³»ç»Ÿ
     */
    void pauseCleaning(String reason);
    
    /**
     * æ¢å¤æ¸…ç†ç³»ç»Ÿ
     */
    void resumeCleaning();
}

@Mod.EventBusSubscriber(modid = ArisSweepingMod.MODID, bus = Mod.EventBusSubscriber.Bus.MOD)
public class APIProvider {
    private static final ArisSweepingAPI INSTANCE = new ArisSweepingAPIImpl();
    
    public static ArisSweepingAPI getAPI() {
        return INSTANCE;
    }
}
```

### 10.2 æ’ä»¶ç³»ç»Ÿ
```java
public class PluginManager {
    private final Map<String, Plugin> loadedPlugins = new ConcurrentHashMap<>();
    
    public void loadPlugins() {
        Path pluginDir = FMLPaths.GAMEDIR.get().resolve("config/arisweeping/plugins");
        
        if (!Files.exists(pluginDir)) {
            try {
                Files.createDirectories(pluginDir);
            } catch (IOException e) {
                LOGGER.error("æ— æ³•åˆ›å»ºæ’ä»¶ç›®å½•", e);
                return;
            }
        }
        
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginDir, "*.jar")) {
            for (Path pluginJar : stream) {
                loadPlugin(pluginJar);
            }
        } catch (IOException e) {
            LOGGER.error("åŠ è½½æ’ä»¶æ—¶å‘ç”Ÿé”™è¯¯", e);
        }
    }
    
    private void loadPlugin(Path pluginJar) {
        try {
            URLClassLoader classLoader = new URLClassLoader(
                new URL[]{pluginJar.toUri().toURL()},
                this.getClass().getClassLoader()
            );
            
            // åŠ è½½æ’ä»¶å…ƒæ•°æ®
            InputStream metaStream = classLoader.getResourceAsStream("plugin.json");
            if (metaStream == null) {
                LOGGER.warn("æ’ä»¶ {} ç¼ºå°‘å…ƒæ•°æ®æ–‡ä»¶", pluginJar.getFileName());
                return;
            }
            
            PluginMetadata metadata = PluginMetadata.fromJson(
                new String(metaStream.readAllBytes(), StandardCharsets.UTF_8)
            );
            
            // å®ä¾‹åŒ–æ’ä»¶ä¸»ç±»
            Class<?> pluginClass = classLoader.loadClass(metadata.getMainClass());
            Plugin plugin = (Plugin) pluginClass.getDeclaredConstructor().newInstance();
            
            // åˆå§‹åŒ–æ’ä»¶
            plugin.onLoad(ArisSweepingAPI.getAPI());
            
            loadedPlugins.put(metadata.getId(), plugin);
            LOGGER.info("å·²åŠ è½½æ’ä»¶: {} v{}", metadata.getName(), metadata.getVersion());
            
        } catch (Exception e) {
            LOGGER.error("åŠ è½½æ’ä»¶å¤±è´¥: {}", pluginJar.getFileName(), e);
        }
    }
}
```

---

## 12. æµ‹è¯•ç­–ç•¥

### 11.1 å•å…ƒæµ‹è¯•
```java
public class EntityCleanerTest {
    @Test
    public void testItemEntityCleaning() {
        // åˆ›å»ºæµ‹è¯•ç¯å¢ƒ
        TestLevel level = new TestLevel();
        
        // æ·»åŠ æµ‹è¯•å®ä½“
        ItemEntity item1 = createTestItem(level, Items.DIRT, 1000); // è€ç‰©å“
        ItemEntity item2 = createTestItem(level, Items.STONE, 100); // æ–°ç‰©å“
        
        // æ‰§è¡Œæ¸…ç†
        ItemEntityFilter filter = new ItemEntityFilter();
        filter.setAgeThreshold(500);
        
        List<Entity> toRemove = filter.filterEntities(Arrays.asList(item1, item2));
        
        // éªŒè¯ç»“æœ
        assertEquals(1, toRemove.size());
        assertEquals(item1, toRemove.get(0));
    }
    
    @Test
    public void testThreadSafety() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(10);
        AtomicInteger counter = new AtomicInteger(0);
        
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    SafeEntityAccess.performSafeOperation(() -> {
                        counter.incrementAndGet();
                        Thread.sleep(10);
                        return null;
                    });
                } catch (Exception e) {
                    fail("ä¸åº”è¯¥æŠ›å‡ºå¼‚å¸¸: " + e.getMessage());
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
        assertEquals(10, counter.get());
    }
}
```

### 11.2 é›†æˆæµ‹è¯•
```java
public class IntegrationTest {
    @Test
    public void testFullCleaningCycle() {
        // åˆ›å»ºæµ‹è¯•ä¸–ç•Œ
        TestServerLevel level = TestWorldHelper.createTestWorld();
        
        // é…ç½®æ¸…ç†å‚æ•°
        ConfigData config = new ConfigData();
        config.setItemCleaningEnabled(true);
        config.setItemAgeThreshold(100);
        
        // åˆ›å»ºæ¸…ç†ç®¡ç†å™¨
        AsyncTaskManager taskManager = new AsyncTaskManager();
        EntityCleaner cleaner = new EntityCleaner(taskManager, config);
        
        // æ·»åŠ å¤§é‡æµ‹è¯•å®ä½“
        for (int i = 0; i < 1000; i++) {
            createTestItem(level, Items.COBBLESTONE, i * 10);
        }
        
        // æ‰§è¡Œæ¸…ç†
        CompletableFuture<CleaningResult> future = cleaner.cleanLevel(level);
        CleaningResult result = future.get(30, TimeUnit.SECONDS);
        
        // éªŒè¯ç»“æœ
        assertTrue(result.getRemovedCount() > 0);
        assertTrue(result.getDurationMs() < 5000); // ä¸åº”è¯¥è¶…è¿‡5ç§’
        
        // éªŒè¯å®é™…å®ä½“å·²è¢«ç§»é™¤
        int remainingItems = countItemEntities(level);
        assertTrue(remainingItems < 1000);
    }
}
```

---

## 13. éƒ¨ç½²å’Œç»´æŠ¤

### 12.1 æ„å»ºè„šæœ¬ (build.gradle)
```gradle
plugins {
    id 'eclipse'
    id 'maven-publish'
    id 'net.minecraftforge.gradle' version '6.0.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
}

version = '1.0.0'
group = 'com.arisweeping'
archivesBaseName = 'arisweeping'

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

minecraft {
    mappings channel: 'official', version: '1.20.1'
    
    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            mods {
                arisweeping {
                    source sourceSets.main
                }
            }
        }
        
        server {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            mods {
                arisweeping {
                    source sourceSets.main
                }
            }
        }
    }
}

dependencies {
    minecraft 'net.minecraftforge:forge:1.20.1-47.2.0'
    
    // æµ‹è¯•ä¾èµ–
    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'
    testImplementation 'org.mockito:mockito-core:4.6.1'
    testImplementation 'org.mockito:mockito-junit-jupiter:4.6.1'
}

test {
    useJUnitPlatform()
}

jar {
    manifest {
        attributes([
            "Specification-Title": "ArisSweeping",
            "Specification-Vendor": "ArisTeam",
            "Specification-Version": "1",
            "Implementation-Title": project.name,
            "Implementation-Version": "${version}",
            "Implementation-Vendor" :"ArisTeam",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}
```

### 12.2 æ€§èƒ½ç›‘æ§
```java
public class PerformanceMonitor {
    private final MeterRegistry meterRegistry = Metrics.globalRegistry;
    private final Timer cleaningTimer;
    private final Counter entityCounter;
    private final Gauge memoryGauge;
    
    public PerformanceMonitor() {
        this.cleaningTimer = Timer.builder("arisweeping.cleaning.duration")
            .description("æ¸…ç†æ“ä½œè€—æ—¶")
            .register(meterRegistry);
            
        this.entityCounter = Counter.builder("arisweeping.entities.removed")
            .description("ç§»é™¤çš„å®ä½“æ•°é‡")
            .register(meterRegistry);
            
        this.memoryGauge = Gauge.builder("arisweeping.memory.usage")
            .description("å†…å­˜ä½¿ç”¨é‡")
            .register(meterRegistry, this, PerformanceMonitor::getMemoryUsage);
    }
    
    public void recordCleaningOperation(long durationMs, int entitiesRemoved) {
        cleaningTimer.record(durationMs, TimeUnit.MILLISECONDS);
        entityCounter.increment(entitiesRemoved);
    }
    
    private double getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        return (runtime.totalMemory() - runtime.freeMemory()) / 1024.0 / 1024.0; // MB
    }
    
    public void generateReport() {
        LOGGER.info("=== æ€§èƒ½æŠ¥å‘Š ===");
        LOGGER.info("æ¸…ç†æ“ä½œæ€»æ¬¡æ•°: {}", cleaningTimer.count());
        LOGGER.info("å¹³å‡æ¸…ç†æ—¶é—´: {}ms", cleaningTimer.mean(TimeUnit.MILLISECONDS));
        LOGGER.info("æ€»ç§»é™¤å®ä½“æ•°: {}", entityCounter.count());
        LOGGER.info("å½“å‰å†…å­˜ä½¿ç”¨: {}MB", getMemoryUsage());
    }
}
```

---

## 14. æ•…éšœæ’é™¤æŒ‡å—

### 13.1 å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

#### é—®é¢˜1: æ¸…ç†æ•ˆæœä¸æ˜æ˜¾
**å¯èƒ½åŸå› :**
- é…ç½®å‚æ•°è®¾ç½®ä¸åˆç†
- å®ä½“è¿‡æ»¤æ¡ä»¶è¿‡äºä¸¥æ ¼
- æ¸…ç†é—´éš”æ—¶é—´è¿‡é•¿

**è§£å†³æ–¹æ¡ˆ:**
```java
// è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºè¯¦ç»†ä¿¡æ¯
public void debugCleaningProcess(CleaningContext context) {
    if (ModConfig.isDebugMode()) {
        LOGGER.info("=== æ¸…ç†è°ƒè¯•ä¿¡æ¯ ===");
        LOGGER.info("åŒºå—: {}", context.getChunkPos());
        LOGGER.info("æ€»å®ä½“æ•°: {}", context.getTotalEntities());
        LOGGER.info("ç¬¦åˆæ¡ä»¶å®ä½“æ•°: {}", context.getFilteredEntities());
        LOGGER.info("å®é™…ç§»é™¤æ•°: {}", context.getRemovedEntities());
        
        // æŒ‰ç±»å‹ç»Ÿè®¡
        Map<EntityType<?>, Long> typeCount = context.getAllEntities().stream()
            .collect(Collectors.groupingBy(Entity::getType, Collectors.counting()));
        
        typeCount.forEach((type, count) -> 
            LOGGER.info("  {}: {} ä¸ª", type.getDescription().getString(), count));
    }
}
```

#### é—®é¢˜2: æ¸¸æˆå¡é¡¿
**å¯èƒ½åŸå› :**
- çº¿ç¨‹æ± é…ç½®ä¸å½“
- åŒæ—¶å¤„ç†è¿‡å¤šåŒºå—
- å†…å­˜ä½¿ç”¨è¿‡é«˜

**è§£å†³æ–¹æ¡ˆ:**
```java
// è‡ªé€‚åº”æ€§èƒ½è°ƒæ•´
public class AdaptivePerformanceManager {
    private volatile int maxConcurrentTasks = 4;
    private final Queue<Long> recentExecutionTimes = new ConcurrentLinkedQueue<>();
    private final MinecraftServer server; // åœ¨æ„é€ å‡½æ•°ä¸­ä¼ å…¥
    
    public AdaptivePerformanceManager(MinecraftServer server) {
        this.server = server;
    }
    
    public void adjustPerformanceSettings() {
        double avgExecutionTime = calculateAverageExecutionTime();
        // åœ¨1.20.1ä¸­è·å–TPSçš„æ­£ç¡®æ–¹å¼
        double tps = server != null ? Math.min(20.0, 1000.0 / server.getAverageTickTime()) : 20.0;
        
        if (tps < 15.0 || avgExecutionTime > 100) {
            // æ€§èƒ½ä¸‹é™ï¼Œå‡å°‘å¹¶å‘
            maxConcurrentTasks = Math.max(1, maxConcurrentTasks - 1);
            LOGGER.warn("æ£€æµ‹åˆ°æ€§èƒ½ä¸‹é™ï¼Œé™ä½å¹¶å‘æ•°è‡³: {}", maxConcurrentTasks);
        } else if (tps > 18.0 && avgExecutionTime < 50) {
            // æ€§èƒ½è‰¯å¥½ï¼Œå¯ä»¥å¢åŠ å¹¶å‘
            maxConcurrentTasks = Math.min(8, maxConcurrentTasks + 1);
            LOGGER.info("æ€§èƒ½è‰¯å¥½ï¼Œå¢åŠ å¹¶å‘æ•°è‡³: {}", maxConcurrentTasks);
        }
    }
}
```

### 13.2 æ—¥å¿—åˆ†æå·¥å…·
```java
public class LogAnalyzer {
    public void analyzePerformanceLogs(Path logFile) throws IOException {
        Pattern pattern = Pattern.compile(
            "æ¸…ç†å®Œæˆ: åŒºå—\\[(\\d+), (\\d+)\\] ç§»é™¤(\\d+)ä¸ªå®ä½“, è€—æ—¶(\\d+)ms");
        
        Map<String, List<Long>> executionTimes = new HashMap<>();
        Map<String, Integer> entityCounts = new HashMap<>();
        
        Files.lines(logFile)
            .forEach(line -> {
                Matcher matcher = pattern.matcher(line);
                if (matcher.find()) {
                    String chunk = matcher.group(1) + "," + matcher.group(2);
                    int entities = Integer.parseInt(matcher.group(3));
                    long time = Long.parseLong(matcher.group(4));
                    
                    executionTimes.computeIfAbsent(chunk, k -> new ArrayList<>()).add(time);
                    entityCounts.merge(chunk, entities, Integer::sum);
                }
            });
        
        // åˆ†æç»“æœ
        analyzeResults(executionTimes, entityCounts);
    }
    
    private void analyzeResults(Map<String, List<Long>> times, Map<String, Integer> counts) {
        LOGGER.info("=== æ—¥å¿—åˆ†æç»“æœ ===");
        
        // æ‰¾å‡ºè€—æ—¶æœ€é•¿çš„åŒºå—
        times.entrySet().stream()
            .max(Comparator.comparing(e -> e.getValue().stream().mapToLong(Long::longValue).average().orElse(0)))
            .ifPresent(entry -> 
                LOGGER.info("æœ€æ…¢åŒºå—: {} å¹³å‡è€—æ—¶: {}ms", 
                    entry.getKey(), 
                    entry.getValue().stream().mapToLong(Long::longValue).average().orElse(0)));
        
        // æ‰¾å‡ºå®ä½“æœ€å¤šçš„åŒºå—
        counts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .ifPresent(entry -> 
                LOGGER.info("å®ä½“æœ€å¤šåŒºå—: {} æ€»è®¡: {}ä¸ª", entry.getKey(), entry.getValue()));
    }
}
```

---

## 15. MiniHUDé£æ ¼å¯è§†åŒ–é…ç½®ç•Œé¢

### 14.1 è®¾è®¡ç†å¿µ
å€Ÿé‰´MiniHUDçš„è®¾è®¡æ€è·¯ï¼Œå®ç°è½»é‡çº§ã€é«˜æ•ˆçš„æ¸¸æˆå†…é…ç½®ç•Œé¢ï¼š
- **å³æ—¶åé¦ˆ**: é…ç½®ä¿®æ”¹ç«‹å³ç”Ÿæ•ˆï¼Œæ— éœ€é‡å¯
- **åˆ†ç±»ç®¡ç†**: é…ç½®æŒ‰åŠŸèƒ½æ¨¡å—åˆ†ç±»å±•ç¤º
- **å¿«é€Ÿåˆ‡æ¢**: ä¸€é”®å¼€å¯/å…³é—­åŠŸèƒ½æ¨¡å—
- **å®æ—¶ç»Ÿè®¡**: æ˜¾ç¤ºæ¸…ç†æ•ˆæœå’Œæ€§èƒ½æ•°æ®
- **å“åº”å¼å¸ƒå±€**: é€‚é…ä¸åŒå±å¹•åˆ†è¾¨ç‡

### 14.2 é…ç½®ç•Œé¢æ¶æ„

#### 14.2.1 ä¸»é…ç½®ç®¡ç†å™¨
```java
public class MiniHUDStyleConfigManager {
    private static final Map<String, ConfigCategory> categories = new LinkedHashMap<>();
    private static final List<ConfigChangeListener> listeners = new ArrayList<>();
    
    static {
        // æ³¨å†Œé…ç½®åˆ†ç±»
        registerCategory("general", new GeneralConfigCategory());
        registerCategory("items", new ItemCleaningCategory());
        registerCategory("animals", new AnimalCleaningCategory());
        registerCategory("performance", new PerformanceCategory());
        registerCategory("display", new DisplayCategory());
        registerCategory("tasks", new TaskManagementCategory()); // æ–°å¢ä»»åŠ¡ç®¡ç†åˆ†ç±»
    }
    
    public static void registerCategory(String id, ConfigCategory category) {
        categories.put(id, category);
    }
    
    public static Collection<ConfigCategory> getCategories() {
        return categories.values();
    }
    
    public static void openConfigScreen() {
        Minecraft.getInstance().setScreen(new MiniHUDConfigScreen());
    }
}
```

#### 14.2.2 ä¸»é…ç½®ç•Œé¢
```java
public class MiniHUDConfigScreen extends Screen {
    private static final int SIDEBAR_WIDTH = 120;
    private static final int CONTENT_PADDING = 10;
    private static final int CATEGORY_HEIGHT = 25;
    
    private final List<CategoryButton> categoryButtons = new ArrayList<>();
    private ConfigCategory currentCategory;
    private ScrollPanel scrollPanel;
    
    public MiniHUDConfigScreen() {
        super(Component.literal("ArisSweeping Configuration"));
    }
    
    @Override
    protected void init() {
        super.init();
        
        // åˆ›å»ºä¾§è¾¹æ åˆ†ç±»æŒ‰é’®
        createCategoryButtons();
        
        // åˆ›å»ºå†…å®¹åŒºåŸŸæ»šåŠ¨é¢æ¿
        createContentPanel();
        
        // åˆ›å»ºåº•éƒ¨æŒ‰é’®
        createBottomButtons();
        
        // é€‰æ‹©ç¬¬ä¸€ä¸ªåˆ†ç±»
        if (!categoryButtons.isEmpty()) {
            selectCategory(categoryButtons.get(0).getCategory());
        }
    }
    
    private void createCategoryButtons() {
        int y = 40;
        for (ConfigCategory category : MiniHUDStyleConfigManager.getCategories()) {
            CategoryButton button = new CategoryButton(
                10, y, SIDEBAR_WIDTH - 20, 20,
                category.getDisplayName(),
                category,
                this::selectCategory
            );
            categoryButtons.add(button);
            addRenderableWidget(button);
            y += CATEGORY_HEIGHT;
        }
    }
    
    private void createContentPanel() {
        int contentX = SIDEBAR_WIDTH + CONTENT_PADDING;
        int contentWidth = this.width - contentX - CONTENT_PADDING;
        int contentHeight = this.height - 80;
        
        scrollPanel = new ScrollPanel(
            contentX, 40, contentWidth, contentHeight
        );
        addRenderableWidget(scrollPanel);
    }
    
    private void selectCategory(ConfigCategory category) {
        this.currentCategory = category;
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        categoryButtons.forEach(btn -> btn.setSelected(btn.getCategory() == category));
        
        // é‡æ–°æ„å»ºå†…å®¹é¢æ¿
        rebuildContentPanel();
    }
    
    private void rebuildContentPanel() {
        if (currentCategory == null) return;
        
        scrollPanel.clearContent();
        
        // æ·»åŠ åˆ†ç±»æ ‡é¢˜
        scrollPanel.addWidget(new TitleWidget(currentCategory.getDisplayName()));
        
        // æ·»åŠ åˆ†ç±»æè¿°
        if (currentCategory.getDescription() != null) {
            scrollPanel.addWidget(new DescriptionWidget(currentCategory.getDescription()));
        }
        
        // æ·»åŠ é…ç½®é¡¹
        for (ConfigEntry entry : currentCategory.getEntries()) {
            AbstractConfigWidget widget = createConfigWidget(entry);
            if (widget != null) {
                scrollPanel.addWidget(widget);
            }
        }
    }
    
    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        // ç»˜åˆ¶èƒŒæ™¯
        renderBackground(graphics);
        
        // ç»˜åˆ¶ä¾§è¾¹æ èƒŒæ™¯
        graphics.fill(0, 0, SIDEBAR_WIDTH, this.height, 0x80000000);
        graphics.fill(SIDEBAR_WIDTH, 0, SIDEBAR_WIDTH + 1, this.height, 0xFF404040);
        
        super.render(graphics, mouseX, mouseY, partialTicks);
        
        // ç»˜åˆ¶æ ‡é¢˜
        graphics.drawCenteredString(
            font, this.title, 
            this.width / 2, 15, 
            0xFFFFFF
        );
        
        // ç»˜åˆ¶å®æ—¶ç»Ÿè®¡ä¿¡æ¯
        renderStatistics(graphics);
    }
    
    private void renderStatistics(GuiGraphics graphics) {
        StatisticsCollector stats = StatisticsCollector.getInstance();
        SmartTaskManager taskManager = SmartTaskManager.getInstance();
        
        int rightX = this.width - 10;
        int y = this.height - 60; // å¢åŠ ç©ºé—´æ˜¾ç¤ºæ›´å¤šä¿¡æ¯
        
        String statusText = "æ¸…ç†çŠ¶æ€: " + (ArisSweepingMod.isEnabled() ? "Â§aå¯ç”¨" : "Â§cç¦ç”¨");
        graphics.drawString(font, statusText, rightX - font.width(statusText), y, 0xFFFFFF);
        y -= 12;
        
        String entityCount = "å·²æ¸…ç†: Â§e" + stats.getTotalRemovedEntities() + " Â§fä¸ªå®ä½“";
        graphics.drawString(font, entityCount, rightX - font.width(entityCount), y, 0xFFFFFF);
        y -= 12;
        
        String avgTime = "å¹³å‡è€—æ—¶: Â§b" + String.format("%.1f", stats.getAverageCleaningTime()) + "ms";
        graphics.drawString(font, avgTime, rightX - font.width(avgTime), y, 0xFFFFFF);
        y -= 12;
        
        // æ–°å¢ï¼šä»»åŠ¡ç®¡ç†çŠ¶æ€
        TaskManagerStatus taskStatus = taskManager.getStatus();
        String taskInfo = "æ´»è·ƒä»»åŠ¡: Â§d" + taskStatus.getActiveTasks() + " Â§f| é˜Ÿåˆ—: Â§d" + taskStatus.getQueueSize();
        graphics.drawString(font, taskInfo, rightX - font.width(taskInfo), y, 0xFFFFFF);
        y -= 12;
        
        String undoInfo = "å¯æ’¤é”€: Â§a" + taskStatus.getUndoableOperations() + " Â§fæ¬¡æ“ä½œ";
        graphics.drawString(font, undoInfo, rightX - font.width(undoInfo), y, 0xFFFFFF);
    }
}
```

### 14.3 é…ç½®ç»„ä»¶ç³»ç»Ÿ

#### 14.3.1 æŠ½è±¡é…ç½®ç»„ä»¶
```java
public abstract class AbstractConfigWidget extends AbstractWidget {
    protected final ConfigEntry entry;
    protected final Consumer<Object> valueConsumer;
    
    public AbstractConfigWidget(int x, int y, int width, int height, 
                               ConfigEntry entry, Consumer<Object> valueConsumer) {
        super(x, y, width, height, entry.getDisplayName());
        this.entry = entry;
        this.valueConsumer = valueConsumer;
    }
    
    public abstract void resetToDefault();
    public abstract Object getCurrentValue();
    
    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        super.render(graphics, mouseX, mouseY, partialTicks);
        
        // æ¸²æŸ“å·¥å…·æç¤º
        if (isHovered() && entry.getTooltip() != null) {
            renderTooltip(graphics, mouseX, mouseY);
        }
    }
    
    protected void renderTooltip(GuiGraphics graphics, int mouseX, int mouseY) {
        List<Component> tooltip = Arrays.asList(entry.getTooltip());
        graphics.renderTooltip(Minecraft.getInstance().font, tooltip, mouseX, mouseY);
    }
}
```

#### 14.3.2 å¸ƒå°”å¼€å…³ç»„ä»¶
```java
public class BooleanToggleWidget extends AbstractConfigWidget {
    private final Button toggleButton;
    private boolean currentValue;
    
    public BooleanToggleWidget(int x, int y, int width, ConfigEntry entry, 
                              Consumer<Object> valueConsumer) {
        super(x, y, width, 20, entry, valueConsumer);
        
        this.currentValue = (Boolean) entry.getCurrentValue();
        this.toggleButton = Button.builder(
            Component.literal(getButtonText()),
            this::onToggle
        ).bounds(x + width - 60, y, 60, 20).build();
    }
    
    private void onToggle(Button button) {
        currentValue = !currentValue;
        button.setMessage(Component.literal(getButtonText()));
        valueConsumer.accept(currentValue);
    }
    
    private String getButtonText() {
        return currentValue ? "Â§aå¼€å¯" : "Â§cå…³é—­";
    }
    
    @Override
    public void resetToDefault() {
        currentValue = (Boolean) entry.getDefaultValue();
        toggleButton.setMessage(Component.literal(getButtonText()));
        valueConsumer.accept(currentValue);
    }
    
    @Override
    public Object getCurrentValue() {
        return currentValue;
    }
    
    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        // æ¸²æŸ“æ ‡ç­¾
        graphics.drawString(
            Minecraft.getInstance().font, 
            this.getMessage().getString(),
            getX(), getY() + 6, 
            0xFFFFFF
        );
        
        // æ¸²æŸ“æŒ‰é’®
        toggleButton.render(graphics, mouseX, mouseY, partialTicks);
        
        super.render(graphics, mouseX, mouseY, partialTicks);
    }
    
    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        return toggleButton.mouseClicked(mouseX, mouseY, button);
    }
}
```

#### 14.3.3 æ•°å€¼æ»‘å—ç»„ä»¶
```java
public class NumberSliderWidget extends AbstractConfigWidget {
    private final AbstractSlider slider;
    private final int minValue;
    private final int maxValue;
    private int currentValue;
    
    public NumberSliderWidget(int x, int y, int width, ConfigEntry entry, 
                             Consumer<Object> valueConsumer, int minValue, int maxValue) {
        super(x, y, width, 20, entry, valueConsumer);
        
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.currentValue = (Integer) entry.getCurrentValue();
        
        this.slider = new AbstractSlider(
            x + width - 120, y, 120, 20,
            Component.literal(entry.getDisplayName().getString() + ": " + currentValue),
            (double) (currentValue - minValue) / (maxValue - minValue)
        ) {
            @Override
            protected void updateMessage() {
                currentValue = (int) (minValue + value * (maxValue - minValue));
                setMessage(Component.literal(entry.getDisplayName().getString() + ": " + currentValue));
            }
            
            @Override
            protected void applyValue() {
                valueConsumer.accept(currentValue);
            }
        };
    }
    
    @Override
    public void resetToDefault() {
        currentValue = (Integer) entry.getDefaultValue();
        slider.setValue((double) (currentValue - minValue) / (maxValue - minValue));
        valueConsumer.accept(currentValue);
    }
    
    @Override
    public Object getCurrentValue() {
        return currentValue;
    }
    
    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        // æ¸²æŸ“æ ‡ç­¾
        graphics.drawString(
            Minecraft.getInstance().font, 
            this.getMessage().getString(),
            getX(), getY() + 6, 
            0xFFFFFF
        );
        
        // æ¸²æŸ“æ»‘å—
        slider.render(graphics, mouseX, mouseY, partialTicks);
        
        super.render(graphics, mouseX, mouseY, partialTicks);
    }
    
    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        return slider.mouseClicked(mouseX, mouseY, button);
    }
    
    @Override
    public boolean mouseDragged(double mouseX, double mouseY, int button, double deltaX, double deltaY) {
        return slider.mouseDragged(mouseX, mouseY, button, deltaX, deltaY);
    }
}
```

### 14.4 é…ç½®åˆ†ç±»å®šä¹‰

#### 14.4.1 ç‰©å“æ¸…ç†åˆ†ç±»
```java
public class ItemCleaningCategory implements ConfigCategory {
    private final List<ConfigEntry> entries = new ArrayList<>();
    
    public ItemCleaningCategory() {
        entries.add(new BooleanConfigEntry(
            "item_cleaning_enabled",
            Component.literal("å¯ç”¨ç‰©å“æ¸…ç†"),
            Component.literal("è‡ªåŠ¨æ¸…ç†è¿‡æœŸçš„æ‰è½ç‰©å“"),
            true,
            ConfigData::isItemCleaningEnabled,
            ConfigData::setItemCleaningEnabled
        ));
        
        entries.add(new IntegerConfigEntry(
            "item_age_threshold",
            Component.literal("ç‰©å“å­˜æ´»æ—¶é—´"),
            Component.literal("ç‰©å“å­˜åœ¨å¤šå°‘ç§’åè¢«æ¸…ç†ï¼ˆç§’ï¼‰"),
            300,
            30, 3600,
            ConfigData::getItemAgeThreshold,
            ConfigData::setItemAgeThreshold
        ));
        
        entries.add(new IntegerConfigEntry(
            "max_items_per_chunk",
            Component.literal("åŒºå—ç‰©å“é™åˆ¶"),
            Component.literal("æ¯ä¸ªåŒºå—æœ€å¤šå…è®¸çš„ç‰©å“æ•°é‡"),
            100,
            10, 1000,
            ConfigData::getMaxItemsPerChunk,
            ConfigData::setMaxItemsPerChunk
        ));
        
        entries.add(new StringListConfigEntry(
            "item_whitelist",
            Component.literal("ç‰©å“ç™½åå•"),
            Component.literal("è¿™äº›ç‰©å“æ°¸è¿œä¸ä¼šè¢«æ¸…ç†"),
            Arrays.asList("minecraft:diamond", "minecraft:netherite_ingot"),
            ConfigData::getItemWhitelist,
            ConfigData::setItemWhitelist
        ));
    }
    
    @Override
    public String getId() {
        return "items";
    }
    
    @Override
    public Component getDisplayName() {
        return Component.literal("Â§eç‰©å“æ¸…ç†");
    }
    
    @Override
    public Component getDescription() {
        return Component.literal("é…ç½®æ‰è½ç‰©å“çš„è‡ªåŠ¨æ¸…ç†è§„åˆ™");
    }
    
    @Override
    public List<ConfigEntry> getEntries() {
        return entries;
    }
}
```

#### 14.4.2 åŠ¨ç‰©æ¸…ç†åˆ†ç±»
```java
public class AnimalCleaningCategory implements ConfigCategory {
    private final List<ConfigEntry> entries = new ArrayList<>();
    
    public AnimalCleaningCategory() {
        entries.add(new BooleanConfigEntry(
            "animal_cleaning_enabled",
            Component.literal("å¯ç”¨åŠ¨ç‰©æ¸…ç†"),
            Component.literal("è‡ªåŠ¨æ¸…ç†è¿‡å¯†çš„åŠ¨ç‰©ç¾¤ä½“"),
            true,
            ConfigData::isAnimalCleaningEnabled,
            ConfigData::setAnimalCleaningEnabled
        ));
        
        entries.add(new IntegerConfigEntry(
            "animal_density_limit",
            Component.literal("åŠ¨ç‰©å¯†åº¦é™åˆ¶"),
            Component.literal("æŒ‡å®šåŒºåŸŸå†…åŒç±»åŠ¨ç‰©çš„æœ€å¤§æ•°é‡"),
            20,
            5, 100,
            ConfigData::getAnimalDensityLimit,
            ConfigData::setAnimalDensityLimit
        ));
        
        entries.add(new IntegerConfigEntry(
            "density_check_radius",
            Component.literal("å¯†åº¦æ£€æŸ¥åŠå¾„"),
            Component.literal("æ£€æŸ¥åŠ¨ç‰©å¯†åº¦çš„èŒƒå›´ï¼ˆæ–¹å—ï¼‰"),
            32,
            16, 128,
            ConfigData::getDensityCheckRadius,
            ConfigData::setDensityCheckRadius
        ));
        
        entries.add(new BooleanConfigEntry(
            "breeding_protection",
            Component.literal("ç¹æ®–ä¿æŠ¤"),
            Component.literal("ä¿æŠ¤æ­£åœ¨ç¹æ®–æˆ–å¹¼å¹´çš„åŠ¨ç‰©"),
            true,
            ConfigData::isBreedingProtectionEnabled,
            ConfigData::setBreedingProtectionEnabled
        ));
    }
    
    @Override
    public String getId() {
        return "animals";
    }
    
    @Override
    public Component getDisplayName() {
        return Component.literal("Â§6åŠ¨ç‰©æ¸…ç†");
    }
    
    @Override
    public Component getDescription() {
        return Component.literal("é…ç½®åŠ¨ç‰©å¯†åº¦æ§åˆ¶å’Œæ¸…ç†è§„åˆ™");
    }
    
    @Override
    public List<ConfigEntry> getEntries() {
        return entries;
    }
}
```

#### 14.4.3 ä»»åŠ¡ç®¡ç†åˆ†ç±»
```java
public class TaskManagementCategory implements ConfigCategory {
    private final List<ConfigEntry> entries = new ArrayList<>();
    
    public TaskManagementCategory() {
        // è¿™ä¸ªåˆ†ç±»ä¸»è¦æ˜¯åŠŸèƒ½æ€§çš„ï¼Œä¸æ˜¯é…ç½®æ€§çš„
        entries.add(new ActionButtonConfigEntry(
            "undo_last_operation",
            Component.literal("æ’¤é”€ä¸Šæ¬¡æ“ä½œ"),
            Component.literal("æ¢å¤ä¸Šä¸€æ¬¡æ¸…ç†æ“ä½œåˆ é™¤çš„å®ä½“"),
            this::undoLastOperation,
            this::canUndoLastOperation
        ));
        
        entries.add(new UndoHistoryConfigEntry(
            "undo_history",
            Component.literal("æ“ä½œå†å²"),
            Component.literal("æŸ¥çœ‹å’Œç®¡ç†å¯æ’¤é”€çš„æ¸…ç†æ“ä½œ"),
            this::getUndoHistory,
            this::undoSpecificOperation
        ));
        
        entries.add(new TaskStatusConfigEntry(
            "task_status",
            Component.literal("ä»»åŠ¡çŠ¶æ€"),
            Component.literal("æŸ¥çœ‹å½“å‰ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€"),
            this::getTaskStatus
        ));
        
        entries.add(new ActionButtonConfigEntry(
            "pause_all_tasks",
            Component.literal("æš‚åœæ‰€æœ‰ä»»åŠ¡"),
            Component.literal("ç«‹å³åœæ­¢æ‰€æœ‰æ¸…ç†ä»»åŠ¡çš„æ‰§è¡Œ"),
            this::pauseAllTasks,
            () -> !SmartTaskManager.getInstance().isPaused()
        ));
        
        entries.add(new ActionButtonConfigEntry(
            "resume_all_tasks",
            Component.literal("æ¢å¤æ‰€æœ‰ä»»åŠ¡"),
            Component.literal("ç»§ç»­æ‰§è¡Œæš‚åœçš„æ¸…ç†ä»»åŠ¡"),
            this::resumeAllTasks,
            () -> SmartTaskManager.getInstance().isPaused()
        ));
    }
    
    private void undoLastOperation() {
        SmartTaskManager.getInstance().undoLastOperation()
            .thenAccept(result -> {
                Component message;
                if (result.isSuccess()) {
                    message = Component.literal("Â§aæˆåŠŸæ¢å¤ " + result.getRestoredCount() + " ä¸ªå®ä½“");
                    if (result.getFailedCount() > 0) {
                        message = message.copy().append(Component.literal("Â§eï¼ˆ" + result.getFailedCount() + " ä¸ªå¤±è´¥ï¼‰"));
                    }
                } else {
                    message = Component.literal("Â§cæ’¤é”€å¤±è´¥: " + result.getErrorMessage());
                }
                
                // å‘å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
                Minecraft.getInstance().gui.setOverlayMessage(message, false);
            });
    }
    
    private boolean canUndoLastOperation() {
        return SmartTaskManager.getInstance().getUndoableOperations().size() > 0;
    }
    
    private List<UndoableOperation> getUndoHistory() {
        return SmartTaskManager.getInstance().getUndoableOperations();
    }
    
    private void undoSpecificOperation(UUID taskId) {
        SmartTaskManager.getInstance().undoOperation(taskId)
            .thenAccept(result -> {
                Component message;
                if (result.isSuccess()) {
                    message = Component.literal("Â§aæˆåŠŸæ¢å¤æŒ‡å®šæ“ä½œçš„ " + result.getRestoredCount() + " ä¸ªå®ä½“");
                } else {
                    message = Component.literal("Â§cæ’¤é”€å¤±è´¥: " + result.getErrorMessage());
                }
                
                Minecraft.getInstance().gui.setOverlayMessage(message, false);
            });
    }
    
    private TaskManagerStatus getTaskStatus() {
        return SmartTaskManager.getInstance().getStatus();
    }
    
    private void pauseAllTasks() {
        SmartTaskManager.getInstance().pauseAllTasks();
        Component message = Component.literal("Â§eå·²æš‚åœæ‰€æœ‰æ¸…ç†ä»»åŠ¡");
        Minecraft.getInstance().gui.setOverlayMessage(message, false);
    }
    
    private void resumeAllTasks() {
        SmartTaskManager.getInstance().resumeAllTasks();
        Component message = Component.literal("Â§aå·²æ¢å¤æ‰€æœ‰æ¸…ç†ä»»åŠ¡");
        Minecraft.getInstance().gui.setOverlayMessage(message, false);
    }
    
    @Override
    public String getId() {
        return "tasks";
    }
    
    @Override
    public Component getDisplayName() {
        return Component.literal("Â§dä»»åŠ¡ç®¡ç†");
    }
    
    @Override
    public Component getDescription() {
        return Component.literal("ç®¡ç†æ¸…ç†ä»»åŠ¡çš„æ‰§è¡Œå’Œæ’¤é”€æ“ä½œ");
    }
    
    @Override
    public List<ConfigEntry> getEntries() {
        return entries;
    }
}
}
```

### 14.5 å¿«æ·é”®å’ŒHUDæ˜¾ç¤º

#### 14.5.1 å¿«æ·é”®å¤„ç†
```java
public class ConfigKeyHandler {
    public static final KeyMapping CONFIG_KEY = new KeyMapping(
        "key.arisweeping.config",
        GLFW.GLFW_KEY_K,
        "key.categories.arisweeping"
    );
    
    public static final KeyMapping TOGGLE_KEY = new KeyMapping(
        "key.arisweeping.toggle",
        GLFW.GLFW_KEY_J,
        "key.categories.arisweeping"
    );
    
    public static final KeyMapping UNDO_KEY = new KeyMapping(
        "key.arisweeping.undo",
        GLFW.GLFW_KEY_U,
        "key.categories.arisweeping"
    );
    
    @SubscribeEvent
    public static void onKeyInput(InputEvent.Key event) {
        Minecraft mc = Minecraft.getInstance();
        if (mc.screen != null) return;
        
        if (CONFIG_KEY.consumeClick()) {
            MiniHUDStyleConfigManager.openConfigScreen();
        }
        
        if (TOGGLE_KEY.consumeClick()) {
            boolean newState = !ArisSweepingMod.isEnabled();
            ArisSweepingMod.setEnabled(newState);
            
            // æ˜¾ç¤ºåˆ‡æ¢æç¤º
            Component message = Component.literal(
                "ArisSweeping: " + (newState ? "Â§aå·²å¯ç”¨" : "Â§cå·²ç¦ç”¨")
            );
            mc.gui.setOverlayMessage(message, false);
        }
        
        if (UNDO_KEY.consumeClick()) {
            // å¿«æ·é”®æ’¤é”€ä¸Šæ¬¡æ“ä½œ
            SmartTaskManager.getInstance().undoLastOperation()
                .thenAccept(result -> {
                    Component message;
                    if (result.isSuccess()) {
                        message = Component.literal("Â§aæ’¤é”€æˆåŠŸï¼æ¢å¤äº† " + result.getRestoredCount() + " ä¸ªå®ä½“");
                        if (result.getFailedCount() > 0) {
                            message = message.copy().append(Component.literal("Â§eï¼ˆ" + result.getFailedCount() + " ä¸ªå¤±è´¥ï¼‰"));
                        }
                    } else {
                        message = Component.literal("Â§cæ’¤é”€å¤±è´¥: " + result.getErrorMessage());
                    }
                    mc.gui.setOverlayMessage(message, false);
                });
        }
    }
}
```

#### 14.5.2 HUDä¿¡æ¯æ˜¾ç¤º
```java
public class ConfigHUDRenderer {
    private static boolean showHUD = false;
    
    @SubscribeEvent
    public static void onRenderGameOverlay(RenderGuiEvent.Post event) {
        if (!showHUD || Minecraft.getInstance().options.hideGui) return;
        
        GuiGraphics graphics = event.getGuiGraphics();
        Minecraft mc = Minecraft.getInstance();
        
        renderStatusHUD(graphics, mc);
    }
    
    private static void renderStatusHUD(GuiGraphics graphics, Minecraft mc) {
        StatisticsCollector stats = StatisticsCollector.getInstance();
        
        int x = 10;
        int y = 10;
        int lineHeight = 12;
        
        // èƒŒæ™¯
        graphics.fill(x - 5, y - 5, x + 200, y + 60, 0x80000000);
        graphics.fill(x - 5, y - 5, x + 200, y + 5, 0xFF404040);
        
        // æ ‡é¢˜
        graphics.drawString(mc.font, "Â§bArisSweeping Status", x, y, 0xFFFFFF);
        y += lineHeight + 3;
        
        // çŠ¶æ€ä¿¡æ¯
        String status = "çŠ¶æ€: " + (ArisSweepingMod.isEnabled() ? "Â§aè¿è¡Œä¸­" : "Â§cå·²åœæ­¢");
        graphics.drawString(mc.font, status, x, y, 0xFFFFFF);
        y += lineHeight;
        
        String cleaned = "å·²æ¸…ç†: Â§e" + stats.getTotalRemovedEntities() + " Â§fä¸ªå®ä½“";
        graphics.drawString(mc.font, cleaned, x, y, 0xFFFFFF);
        y += lineHeight;
        
        String avgTime = "å¹³å‡è€—æ—¶: Â§b" + String.format("%.1f", stats.getAverageCleaningTime()) + "ms";
        graphics.drawString(mc.font, avgTime, x, y, 0xFFFFFF);
        y += lineHeight;
        
        // æ–°å¢ï¼šæ’¤é”€ä¿¡æ¯
        SmartTaskManager taskManager = SmartTaskManager.getInstance();
        int undoCount = taskManager.getUndoableOperations().size();
        String undoInfo = "å¯æ’¤é”€: Â§a" + undoCount + " Â§fæ¬¡æ“ä½œ";
        graphics.drawString(mc.font, undoInfo, x, y, 0xFFFFFF);
        y += lineHeight;
        
        // å¿«æ·é”®æç¤º
        String hotkeys = "Â§7" + CONFIG_KEY.getTranslatedKeyMessage().getString() + 
                        ": é…ç½® | " + TOGGLE_KEY.getTranslatedKeyMessage().getString() + ": åˆ‡æ¢ | " +
                        UNDO_KEY.getTranslatedKeyMessage().getString() + ": æ’¤é”€";
        graphics.drawString(mc.font, hotkeys, x, y, 0xFFFFFF);
    }
    
    public static void toggleHUD() {
        showHUD = !showHUD;
    }
    
    public static boolean isHUDVisible() {
        return showHUD;
    }
}
```

### 14.6 é…ç½®æŒä¹…åŒ–

#### 14.6.1 å®¢æˆ·ç«¯é…ç½®æ–‡ä»¶
```java
public class ClientConfigManager {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final Path CONFIG_FILE = FMLPaths.CONFIGDIR.get().resolve("arisweeping-client.json");
    
    private static ClientConfig config = new ClientConfig();
    
    public static void load() {
        if (Files.exists(CONFIG_FILE)) {
            try {
                String json = Files.readString(CONFIG_FILE);
                config = GSON.fromJson(json, ClientConfig.class);
            } catch (Exception e) {
                ArisSweepingMod.LOGGER.error("Failed to load client config", e);
                config = new ClientConfig(); // ä½¿ç”¨é»˜è®¤é…ç½®
            }
        }
        
        save(); // ä¿å­˜é»˜è®¤é…ç½®ï¼ˆå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼‰
    }
    
    public static void save() {
        try {
            Files.createDirectories(CONFIG_FILE.getParent());
            String json = GSON.toJson(config);
            Files.writeString(CONFIG_FILE, json);
        } catch (Exception e) {
            ArisSweepingMod.LOGGER.error("Failed to save client config", e);
        }
    }
    
    public static ClientConfig getConfig() {
        return config;
    }
    
    // å®¢æˆ·ç«¯é…ç½®æ•°æ®ç±»
    public static class ClientConfig {
        public boolean showHUD = false;
        public boolean showNotifications = true;
        public boolean detailedStatistics = false;
        public String selectedCategory = "general";
        
        // GUIç›¸å…³è®¾ç½®
        public int guiScale = 0; // 0 = è‡ªåŠ¨
        public boolean compactMode = false;
        public boolean showTooltips = true;
    }
}
```

---

## ğŸ—ï¸ å·²å®ç°æŠ€æœ¯æ¶æ„æ€»ç»“

### æ ¸å¿ƒè®¾è®¡æ¨¡å¼ âœ…
- **å•ä¾‹æ¨¡å¼** - ArisSweepingModä¸»ç±»ç®¡ç†å…¨å±€ç»„ä»¶å®ä¾‹
- **å·¥å‚æ–¹æ³•** - TaskResulté™æ€å·¥å‚æ–¹æ³•åˆ›å»ºä¸åŒç±»å‹çš„ç»“æœ
- **ç­–ç•¥æ¨¡å¼** - TaskPriorityæšä¸¾æ”¯æŒä¸åŒä¼˜å…ˆçº§ç­–ç•¥
- **çŠ¶æ€æ¨¡å¼** - TaskStatusæšä¸¾å®Œæ•´çš„ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **è§‚å¯Ÿè€…æ¨¡å¼** - ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€å˜åŒ–é€šçŸ¥æœºåˆ¶

### å¹¶å‘è®¾è®¡ âœ…
- **å¤šçº¿ç¨‹æ± æ¶æ„** - æ ¸å¿ƒ/IO/è°ƒåº¦ä¸‰ç±»çº¿ç¨‹æ± åˆ†ç¦»
- **çº¿ç¨‹å®‰å…¨é›†åˆ** - ConcurrentHashMapç®¡ç†æ´»è·ƒä»»åŠ¡
- **åŸå­æ“ä½œ** - AtomicLongå’ŒAtomicIntegerç”¨äºè®¡æ•°å™¨
- **è¯»å†™é”** - TaskQueueä½¿ç”¨ReentrantReadWriteLockä¿æŠ¤é˜Ÿåˆ—æ“ä½œ
- **CompletableFuture** - å¼‚æ­¥ä»»åŠ¡ç»“æœç®¡ç†

### æ•°æ®ç»“æ„è®¾è®¡ âœ…
- **ä¼˜å…ˆçº§é˜Ÿåˆ—** - PriorityBlockingQueueå®ç°ä»»åŠ¡ä¼˜å…ˆçº§è°ƒåº¦
- **ä¸å¯å˜å¯¹è±¡** - TaskResultç­‰ç»“æœå¯¹è±¡è®¾è®¡ä¸ºä¸å¯å˜
- **Builderæ¨¡å¼æ€æƒ³** - TaskExecutionæ„é€ å™¨æ”¯æŒå®Œæ•´å‚æ•°é…ç½®
- **æšä¸¾å¢å¼º** - å¸¦æœ‰è¡Œä¸ºæ–¹æ³•çš„æ™ºèƒ½æšä¸¾ç±»è®¾è®¡

### ä»£ç è´¨é‡ç‰¹æ€§ âœ…
- **çº¿ç¨‹å®‰å…¨æ€§** - æ‰€æœ‰å…±äº«æ•°æ®ç»“æ„éƒ½æœ‰é€‚å½“çš„åŒæ­¥æœºåˆ¶
- **å¼‚å¸¸å¤„ç†** - å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **èµ„æºç®¡ç†** - çº¿ç¨‹æ± çš„ä¼˜é›…å…³é—­å’Œèµ„æºæ¸…ç†
- **å¯é…ç½®æ€§** - é€šè¿‡Constantsç±»é›†ä¸­ç®¡ç†é…ç½®å‚æ•°
- **å¯æ‰©å±•æ€§** - æ¥å£è®¾è®¡æ”¯æŒæœªæ¥åŠŸèƒ½æ‰©å±•

---

**é¡¹ç›®å½“å‰çŠ¶æ€ï¼š** æ ¸å¿ƒæ¶æ„å·²å®Œæˆï¼Œå…·å¤‡åšå®çš„æŠ€æœ¯åŸºç¡€ï¼Œå¯ä»¥å¼€å§‹å®ç°å…·ä½“çš„å®ä½“æ¸…ç†é€»è¾‘å’Œç”¨æˆ·ç•Œé¢åŠŸèƒ½ã€‚
